[]

原

Spring AOP 实现原理

置顶 2013年09月24日 15:23:43 moreevan 阅读数：405248
个人分类： spring

什么是AOP

AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented
Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一
种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为
的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定
义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它
所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明
的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在
OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。

 

而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些
影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方
面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来
，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性
。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的
属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获
得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将
这些剖开的切面复原，不留痕迹。

 

使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主
要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他
们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。
Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如
Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业
逻辑同对其提供支持的通用服务进行分离。”

 

实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消
息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创
建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。


AOP使用场景

AOP用来封装横切关注点，具体可以在下面的场景中使用:

 

Authentication 权限

Caching 缓存

Context passing 内容传递

Error handling 错误处理

Lazy loading　懒加载

Debugging　　调试

logging, tracing, profiling and monitoring　记录跟踪　优化　校准

Performance optimization　性能优化

Persistence　　持久化

Resource pooling　资源池

Synchronization　同步

Transactions 事务


AOP相关概念

方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管
理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。

 

连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。

 

通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、
“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器
做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice:
BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice

 

切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开
发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合
MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查
目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到
目标类上

 

引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何
被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存
。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通
知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口

 

目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO

 

AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。在Spring中，AOP代理可以是JDK
动态代理或者CGLIB代理。

 

织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用
AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完
成织入。


Spring AOP组件

下面这种类图列出了Spring中主要的AOP组件

[SouthEast]

如何使用Spring AOP


可以通过配置文件或者编程的方式来使用Spring AOP。

 

配置可以通过xml文件来进行，大概有四种方式：

1.        配置ProxyFactoryBean，显式地设置advisors, advice, target等

2.        配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是
从容器中获得的其实已经是代理对象

3.        通过<aop:config>来配置

4.        通过<aop: aspectj-autoproxy>来配置，使用AspectJ的注解来标识通知及切入
点

 

也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的
方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对
象

 

具体使用的示例可以google. 这里略去


Spring AOP代理对象的生成


Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由
AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口
，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何
使用JDK来生成代理对象，具体的生成代码放在JdkDynamicAopProxy这个类中，直接上相关
代码：


/**
    * <ol>
    * <li>获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false)
    * <li>检查上面得到的接口中有没有定义 equals或者hashcode的接口
    * <li>调用Proxy.newProxyInstance创建代理对象
    * </ol>
    */
   public Object getProxy(ClassLoader classLoader) {
       if (logger.isDebugEnabled()) {
           logger.debug("Creating JDK dynamic proxy: target source is " +this.advised.getTargetSource());
       }
       Class[] proxiedInterfaces =AopProxyUtils.completeProxiedInterfaces(this.advised);
       findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
       return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
}



 

那这个其实很明了，注释上我也已经写清楚了，不再赘述。

 

下面的问题是，代理对象生成了，那切面是如何织入的？

我们知道InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托
到InvocationHandler.invoke()方法。而通过JdkDynamicAopProxy的签名我们可以看到这
个类其实也实现了InvocationHandler，下面我们就通过分析这个类中实现的invoke()方法
来具体看下Spring AOP是如何织入切面的。

 

publicObject invoke(Object proxy, Method method, Object[] args) throwsThrowable {
       MethodInvocation invocation = null;
       Object oldProxy = null;
       boolean setProxyContext = false;

       TargetSource targetSource = this.advised.targetSource;
       Class targetClass = null;
       Object target = null;

       try {
           //eqauls()方法，具目标对象未实现此方法
           if (!this.equalsDefined && AopUtils.isEqualsMethod(method)){
                return (equals(args[0])? Boolean.TRUE : Boolean.FALSE);
           }

           //hashCode()方法，具目标对象未实现此方法
           if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)){
                return newInteger(hashCode());
           }

           //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知
           if (!this.advised.opaque &&method.getDeclaringClass().isInterface()
                    &&method.getDeclaringClass().isAssignableFrom(Advised.class)) {
                // Service invocations onProxyConfig with the proxy config...
                return AopUtils.invokeJoinpointUsingReflection(this.advised,method, args);
           }

           Object retVal = null;

           if (this.advised.exposeProxy) {
                // Make invocation available ifnecessary.
                oldProxy = AopContext.setCurrentProxy(proxy);
                setProxyContext = true;
           }

           //获得目标对象的类
           target = targetSource.getTarget();
           if (target != null) {
                targetClass = target.getClass();
           }

           //获取可以应用到此方法上的Interceptor列表
           List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass);

           //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)
           if (chain.isEmpty()) {
                retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);
           } else {
                //创建MethodInvocation
                invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
                retVal = invocation.proceed();
           }

           // Massage return value if necessary.
           if (retVal != null && retVal == target &&method.getReturnType().isInstance(proxy)
                    &&!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
                // Special case: it returned"this" and the return type of the method
                // is type-compatible. Notethat we can't help if the target sets
                // a reference to itself inanother returned object.
                retVal = proxy;
           }
           return retVal;
       } finally {
           if (target != null && !targetSource.isStatic()) {
                // Must have come fromTargetSource.
               targetSource.releaseTarget(target);
           }
           if (setProxyContext) {
                // Restore old proxy.
                AopContext.setCurrentProxy(oldProxy);
           }
       }
    }




 

主流程可以简述为：获取可以应用到此方法上的通知链（Interceptor Chain）,如果有,则
应用通知,并执行joinpoint; 如果没有,则直接反射执行joinpoint。而这里的关键是通知
链是如何获取的以及它又是如何执行的，下面逐一分析下。

 

首先，从上面的代码可以看到，通知链是通过
Advised.getInterceptorsAndDynamicInterceptionAdvice()这个方法来获取的,我们来看
下这个方法的实现:

public List<Object>getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) {
                   MethodCacheKeycacheKey = new MethodCacheKey(method);
                   List<Object>cached = this.methodCache.get(cacheKey);
                   if(cached == null) {
                            cached= this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(
                                               this,method, targetClass);
                            this.methodCache.put(cacheKey,cached);
                   }
                   returncached;
         }



 

可以看到实际的获取工作其实是由AdvisorChainFactory.
getInterceptorsAndDynamicInterceptionAdvice()这个方法来完成的，获取到的结果会被
缓存。

下面来分析下这个方法的实现：

 

/**
    * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor,
    * 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断
    * 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回.
    */
    publicList getInterceptorsAndDynamicInterceptionAdvice(Advised config, Methodmethod, Class targetClass) {
       // This is somewhat tricky... we have to process introductions first,
       // but we need to preserve order in the ultimate list.
       List interceptorList = new ArrayList(config.getAdvisors().length);

       //查看是否包含IntroductionAdvisor
       boolean hasIntroductions = hasMatchingIntroductions(config,targetClass);

       //这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor
       AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();

       Advisor[] advisors = config.getAdvisors();
        for (int i = 0; i <advisors.length; i++) {
           Advisor advisor = advisors[i];
           if (advisor instanceof PointcutAdvisor) {
                // Add it conditionally.
                PointcutAdvisor pointcutAdvisor= (PointcutAdvisor) advisor;
                if(config.isPreFiltered() ||pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) {
                    //TODO: 这个地方这两个方法的位置可以互换下
                    //将Advisor转化成Interceptor
                    MethodInterceptor[]interceptors = registry.getInterceptors(advisor);

                    //检查当前advisor的pointcut是否可以匹配当前方法
                    MethodMatcher mm =pointcutAdvisor.getPointcut().getMethodMatcher();

                    if (MethodMatchers.matches(mm,method, targetClass, hasIntroductions)) {
                        if(mm.isRuntime()) {
                            // Creating a newobject instance in the getInterceptors() method
                            // isn't a problemas we normally cache created chains.
                            for (intj = 0; j < interceptors.length; j++) {
                               interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptors[j],mm));
                            }
                        } else {
                            interceptorList.addAll(Arrays.asList(interceptors));
                        }
                    }
                }
           } else if (advisor instanceof IntroductionAdvisor){
                IntroductionAdvisor ia =(IntroductionAdvisor) advisor;
                if(config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) {
                    Interceptor[] interceptors= registry.getInterceptors(advisor);
                    interceptorList.addAll(Arrays.asList(interceptors));
                }
           } else {
                Interceptor[] interceptors =registry.getInterceptors(advisor);
                interceptorList.addAll(Arrays.asList(interceptors));
           }
       }
       return interceptorList;
}



 

这个方法执行完成后，Advised中配置能够应用到连接点或者目标类的Advisor全部被转化
成了MethodInterceptor.

 

接下来我们再看下得到的拦截器链是怎么起作用的。

 

if (chain.isEmpty()) {
                retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);
            } else {
                //创建MethodInvocation
                invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
                retVal = invocation.proceed();
            }



        

         从这段代码可以看出，如果得到的拦截器链为空，则直接反射调用目标方法，否
则创建MethodInvocation，调用其proceed方法，触发拦截器链的执行，来看下具体代码

public Object proceed() throws Throwable {
       //  We start with an index of -1and increment early.
       if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size()- 1) {
           //如果Interceptor执行完了，则执行joinPoint
           return invokeJoinpoint();
       }

       Object interceptorOrInterceptionAdvice =
           this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);

       //如果要动态匹配joinPoint
       if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher){
           // Evaluate dynamic method matcher here: static part will already have
           // been evaluated and found to match.
           InterceptorAndDynamicMethodMatcher dm =
                (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice;
           //动态匹配：运行时参数是否满足匹配条件
           if (dm.methodMatcher.matches(this.method, this.targetClass,this.arguments)) {
                //执行当前Intercetpor
                returndm.interceptor.invoke(this);
           }
           else {
                //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor
                return proceed();
           }
       }
       else {
           // It's an interceptor, so we just invoke it: The pointcutwill have
           // been evaluated statically before this object was constructed.
           //执行当前Intercetpor
           return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
       }
}



代码也比较简单，这里不再赘述。



END

============

By Kevin Fan

 

阅读更多登录后自动展开
想对作者说点什么？我来说一句
 

Spring AOP 原理（面试必备）

L_BestCoder L_BestCoder

02-13 3672

一、AOP是什么？    AOP的全称是Aspect Orient Programming，即面向切面编程。是对
OOP（Object Orient Programming）的一种补充，战门用于处理一些...

 

Spring实现AOP的4种方式

udbnny udbnny

09-08 21.4万

Spring实现AOP的4种方式   先了解AOP的相关术语:1.通知(Advice):通知定义了切面是什
么以及何时使用。描述了切面要完成的工作和何时需要执行这个工作。2.连接点
(Joinpoint)...

 

关于 Spring AOP (AspectJ) 你该知晓的一切

javazejian javazejian

02-21 4.6万

【版权申明】未经博主同意，谢绝转载！（请尊重原创，博主保留追究权） http://
blog.csdn.net/javazejian/article/details/54629058 出自【...

 

Spring IOC和AOP 原理彻底搞懂

luoshenhappy99 luoshenhappy99

08-16 11.8万

Spring提供了很多轻量级应用开发实践的工具集合，这些工具集以接口、抽象类、或工具
类的形式存在于Spring中。通过使用这些工具集，可以实现应用程序与各种开源技术及框
架间的友好整合。比如有关jdbc...

 

深入理解Spring的两大特征（IOC和AOP）

gloomy_114 gloomy_114

04-05 4.3万

众所周知，Spring的核心特性就是IOC和AOP，IOC（Inversion of Control），即“控制反
转”；AOP（Aspect-OrientedProgramming），即“面向切面编程...

 

AOP——SpringAOP（最重要）

qq_16605855 qq_16605855

06-19 1.4万

http://www.cnblogs.com/solverpeng/p/5628100.html 一、AOP: 是对OOP编程方式的一种
补充。翻译过来为“面向切面编程”。可以理解为一个拦截...

 

Spring总结（五）--Spring中使用AOP三种方式

u014206695 u014206695

03-12 1.2万

第一种实现的方式：通过Spring的API实现AOP。第一步： public interface UserService
{ public void add(); public vo...

 

Spring AOP是什么意思，通俗讲解

ios_xumin ios_xumin

11-07 4822

切面编程，就是在你项目原有的功能基础上，通过AOP去添加新的功能，这些功能是建立在
原有功能的基础上的，而且原有的功能并不知道你已经添加了新的功能。比如说，你去ATM
取钱，取钱是一个功能，取完钱后向你的...

 

SpringAOP概念及其使用

wqh8522 wqh8522

06-06 1392

什么是AOPAOP（Aspect Oriented Programming 面向切面编程），通过预编译方式和运行
期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个
热点...

 

springAop

xingzhishen xingzhishen

08-21 499

一、       Introduction 在软件业，AOP为Aspect Oriented Programming的缩写，意为
：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的...

相关热词

和spring spring与下spring spring的 spring和
[feedLoadin]

没有更多推荐了，返回首页

个人资料

[3_moreevan]

moreevan

关注

原创
    56

粉丝
    267

喜欢
    45

评论
    138

等级：
     

访问：
    66万+

积分：
    3506

排名：
    1万+

最新文章

  • jdk动态代理实现原理
  • IO读取速度测试
  • 深入理解 java I/O
  • Tuning Java I/O Performance
  • ubuntu 12 中文输入法的安装

个人分类

  • java 34篇
  • android 13篇
  • spring 3篇
  • servlet&jsp 1篇
  • data structure & algo 4篇
  • design patterns 1篇
  • job 9篇
  • c++ 2篇
  • linux 3篇
  • hardware 1篇
  • windows 1篇

展开

归档

  • 2013年9月 2篇
  • 2012年11月 3篇
  • 2012年10月 2篇
  • 2012年9月 2篇
  • 2012年4月 4篇
  • 2012年3月 7篇
  • 2012年2月 1篇
  • 2012年1月 1篇
  • 2011年12月 1篇
  • 2011年11月 3篇
  • 2011年9月 9篇
  • 2011年8月 20篇
  • 2011年7月 10篇
  • 2011年6月 2篇
  • 2011年4月 5篇
  • 2011年3月 3篇

展开

热门文章

  • Spring AOP 实现原理

    阅读量：405034

  • java 类的初始化

    阅读量：27748

  • java.lang.LinkageError: loader constraint violation

    阅读量：20714

  • Activity的四种LaunchMode(写的真心不错，建议大家都看看)

    阅读量：18667

  • 详解java序列化（一）

    阅读量：17971

最新评论

  • Spring AOP 实现原理

    qq_26323323：推荐下自己的文章 https://blog.csdn.net/qq_26323323/articl...

  • Spring AOP 实现原理

    qq_38663729：[reply]baidu_31945865[/reply] 汝秀也！

  • Spring AOP 实现原理

    baidu_31945865：[reply]Monkey_D_Jie[/reply] 同九义，何汝秀？

  • Spring AOP 实现原理

    weixin_39598667：卧槽，笑死我了。。。

  • java.lang.Linkage...

    u010291448：好用了，贼鸡儿强! &lt;scope&gt;provid...

登录
注册

  • 点赞取消点赞
   
    153
   
  • 评论

    52

  • 目录
  • 收藏
  •  手机看
  • 上一篇
  • 
    [2016080217]
  • 更多
      □ 上一篇

