[]

转

数据库性能优化详解

2017年02月03日 17:38:06 xianmin_yan 阅读数：122173 标签：数据库
个人分类：数据库

出处：



https://www.cnblogs.com/easypass/archive/2010/12/



08/1900127.html


1.数据库访问优化法则


要正确的优化SQL，我们需要快速定位能性的瓶颈点，也就是说快速找到我们SQL主要的开
销在哪里？而大多数情况性能最慢的设备会是瓶颈点，如下载时网络速度可能会是瓶颈点
，本地复制文件时硬盘可能会是瓶颈点，为什么这些一般的工作我们能快速确认瓶颈点呢
，因为我们对这些慢速设备的性能数据有一些基本的认识，如网络带宽是2Mbps，硬盘是每
分钟7200转等等。因此，为了快速找到SQL的性能瓶颈点，我们也需要了解我们计算机系统
的硬件基本性能指标，下图展示的当前主流计算机性能指标数据。

[0_12916366] 

从图上可以看到基本上每种设备都有两个指标：

延时（响应时间）：表示硬件的突发处理能力；

带宽（吞吐量）：代表硬件持续处理能力。

 

从上图可以看出，计算机系统硬件性能从高到代依次为：

CPU——Cache(L1-L2-L3)——内存——SSD硬盘——网络——硬盘

由于SSD硬盘还处于快速发展阶段，所以本文的内容不涉及SSD相关应用系统。

根据数据库知识，我们可以列出每种硬件主要的工作内容：

CPU及内存：缓存数据访问、比较、排序、事务检测、SQL解析、函数或逻辑运算；

网络：结果数据传输、SQL请求、远程数据库访问（dblink）；

硬盘：数据访问、数据写入、日志记录、大数据量排序、大表连接。

 

根据当前计算机硬件的基本性能指标及其在数据库中主要操作内容，可以整理出如下图所
示的性能基本优化法则：

[0_12916372] 

这个优化法则归纳为5个层次：

1、  减少数据访问（减少磁盘访问）

2、  返回更少数据（减少网络传输或磁盘访问）

3、  减少交互次数（减少网络传输）

4、  减少服务器CPU开销（减少CPU及内存开销）

5、  利用更多资源（增加资源）

 

由于每一层优化法则都是解决其对应硬件的性能问题，所以带来的性能提升比例也不一样
。传统数据库系统设计是也是尽可能对低速设备提供优化方法，因此针对低速设备问题的
可优化手段也更多，优化成本也更低。我们任何一个SQL的性能优化都应该按这个规则由上
到下来诊断问题并提出解决方案，而不应该首先想到的是增加资源解决问题。

以下是每个优化法则层级对应优化效果及成本经验参考：

 

┌─────────────────┬────────────┬────────┐
│优化法则         │性能提升效果│优化成本│
├─────────────────┼────────────┼────────┤
│减少数据访问     │1~1000      │低      │
├─────────────────┼────────────┼────────┤
│返回更少数据     │1~100       │低      │
├─────────────────┼────────────┼────────┤
│减少交互次数     │1~20        │低      │
├─────────────────┼────────────┼────────┤
│减少服务器CPU开销│1~5         │低      │
├─────────────────┼────────────┼────────┤
│利用更多资源     │@~10        │高      │
└─────────────────┴────────────┴────────┘

 

接下来，我们针对5种优化法则列举常用的优化手段并结合实例分析。

 

二、Oracle数据库两个基本概念

数据块(Block)

数据块是数据库中数据在磁盘中存储的最小单位，也是一次IO访问的最小单位，一个数据
块通常可以存储多条记录，数据块大小是DBA在创建数据库或表空间时指定，可指定为2K、
4K、8K、16K或32K字节。下图是一个Oracle数据库典型的物理结构，一个数据库可以包括
多个数据文件，一个数据文件内又包含多个数据块；

 

[0_12916366] 

ROWID

ROWID是每条记录在数据库中的唯一标识，通过ROWID可以直接定位记录到对应的文件号及
数据块位置。ROWID内容包括文件号、对像号、数据块号、记录槽号，如下图所示：

 [0_12916366]

三、数据库访问优化法则详解

1、减少数据访问

1.1、创建并使用正确的索引

数据库索引的原理非常简单，但在复杂的表中真正能正确使用索引的人很少，即使是专业
的DBA也不一定能完全做到最优。

索引会大大增加表记录的DML(INSERT,UPDATE,DELETE)开销，正确的索引可以让性能提升
100，1000倍以上，不合理的索引也可能会让性能下降100倍，因此在一个表中创建什么样
的索引需要平衡各种业务需求。

索引常见问题：

索引有哪些种类？

常见的索引有B-TREE索引、位图索引、全文索引，位图索引一般用于数据仓库应用，全文
索引由于使用较少，这里不深入介绍。B-TREE索引包括很多扩展类型，如组合索引、反向
索引、函数索引等等，以下是B-TREE索引的简单介绍：

B-TREE索引也称为平衡树索引(Balance Tree)，它是一种按字段排好序的树形目录结构，
主要用于提升查询性能和唯一约束支持。B-TREE索引的内容包括根节点、分支节点、叶子
节点。

叶子节点内容：索引字段内容+表记录ROWID

根节点，分支节点内容：当一个数据块中不能放下所有索引字段数据时，就会形成树形的
根节点或分支节点，根节点与分支节点保存了索引树的顺序及各层级间的引用关系。

         一个普通的BTREE索引结构示意图如下所示：

 

 [0_12916366]

如果我们把一个表的内容认为是一本字典，那索引就相当于字典的目录，如下图所示：

 [0_12916366]

[0_12916366] 

 

 

图中是一个字典按部首+笔划数的目录，相当于给字典建了一个按部首+笔划的组合索引。

一个表中可以建多个索引，就如一本字典可以建多个目录一样（按拼音、笔划、部首等等
）。

一个索引也可以由多个字段组成，称为组合索引，如上图就是一个按部首+笔划的组合目录
。

SQL什么条件会使用索引？

当字段上建有索引时，通常以下情况会使用索引：

INDEX_COLUMN = ?

INDEX_COLUMN > ?

INDEX_COLUMN >= ?

INDEX_COLUMN < ?

INDEX_COLUMN <= ?

INDEX_COLUMN between ? and ?

INDEX_COLUMN in (?,?,...,?)

INDEX_COLUMN like ?||'%'（后导模糊查询）

T1. INDEX_COLUMN=T2. COLUMN1（两个表通过索引字段关联）

 

SQL什么条件不会使用索引？

 

┌───────────────────┬──────────────────────────────────────────────┐
│查询条件           │不能使用索引原因                              │
├───────────────────┼──────────────────────────────────────────────┤
│INDEX_COLUMN <> ?  │不等于操作不能使用索引                        │
│                   │                                              │
│INDEX_COLUMN not in│                                              │
│(?,?,...,?)        │                                              │
├───────────────────┼──────────────────────────────────────────────┤
│function           │经过普通运算或函数运算后的索引字段不能使用索引│
│(INDEX_COLUMN) = ? │                                              │
│                   │                                              │
│INDEX_COLUMN + 1 = │                                              │
│?                  │                                              │
│                   │                                              │
│INDEX_COLUMN || 'a'│                                              │
│= ?                │                                              │
├───────────────────┼──────────────────────────────────────────────┤
│INDEX_COLUMN like  │含前导模糊查询的Like语法不能使用索引          │
│'%'||?             │                                              │
│                   │                                              │
│INDEX_COLUMN like  │                                              │
│'%'||?||'%'        │                                              │
├───────────────────┼──────────────────────────────────────────────┤
│INDEX_COLUMN is    │B-TREE索引里不保存字段为NULL值记录，因此IS    │
│null               │NULL不能使用索引                              │
├───────────────────┼──────────────────────────────────────────────┤
│NUMBER_INDEX_COLUMN│Oracle在做数值比较时需要将两边的数据转换成同一│
│='12345'           │种数据类型，如果两边数据类型不同时会对字段值隐│
│                   │式转换，相当于加了一层函数处理，所以不能使用索│
│CHAR_INDEX_COLUMN= │引。                                          │
│12345              │                                              │
├───────────────────┼──────────────────────────────────────────────┤
│a.INDEX_COLUMN=    │给索引查询的值应是已知数据，不能是未知字段值。│
│a.COLUMN_1         │                                              │
├───────────────────┴──────────────────────────────────────────────┤
│注：                                                              │
│                                                                  │
│经过函数运算字段的字段要使用可以使用函数索引，这种需求建议与DBA沟 │
│通。                                                              │
│                                                                  │
│有时候我们会使用多个字段的组合索引，如果查询条件中第一个字段不能使│
│用索引，那整个查询也不能使用索引                                  │
│                                                                  │
│如：我们company表建了一个id+name的组合索引，以下SQL是不能使用索引 │
│的                                                                │
│                                                                  │
│Select * from company where name=?                                │
│                                                                  │
│Oracle9i后引入了一种index skip scan的索引方式来解决类似的问题，但 │
│是通过index skip scan提高性能的条件比较特殊，使用不好反而性能会更 │
│差。                                                              │
│                                                                  │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘

我们一般在什么字段上建索引？

这是一个非常复杂的话题，需要对业务及数据充分分析后再能得出结果。主键及外键通常
都要有索引，其它需要建索引的字段应满足以下条件：

1、字段出现在查询条件中，并且查询条件可以使用索引；

2、语句执行频率高，一天会有几千次以上；

3、通过字段条件可筛选的记录集很小，那数据筛选比例是多少才适合？

这个没有固定值，需要根据表数据量来评估，以下是经验公式，可用于快速评估：

小表(记录数小于10000行的表)：筛选比例<10%；

大表：(筛选返回记录数)<(表总记录数*单条记录长度)/10000/16

      单条记录长度≈字段平均内容长度之和+字段数*2

 

以下是一些字段是否需要建B-TREE索引的经验分类：

 

┌─────────────┬──────┬────────────────────────────────────────────────────────┐
│             │字段类│常见字段名                                              │
│             │型    │                                                        │
├─────────────┼──────┼────────────────────────────────────────────────────────┤
│需要建索引的 │主键  │ID,PK                                                   │
│字段         ├──────┼────────────────────────────────────────────────────────┤
│             │外键  │PRODUCT_ID,COMPANY_ID,MEMBER_ID,ORDER_ID,TRADE_ID,PAY_ID│
│             ├──────┼────────────────────────────────────────────────────────┤
│             │有对像│HASH_CODE,USERNAME,IDCARD_NO,EMAIL,TEL_NO,IM_NO         │
│             │或身份│                                                        │
│             │标识意│                                                        │
│             │义字段│                                                        │
├─────────────┼──────┼────────────────────────────────────────────────────────┤
│索引慎用字段,│日期  │GMT_CREATE,GMT_MODIFIED                                 │
│需要进行数据 ├──────┼────────────────────────────────────────────────────────┤
│分布及使用场 │年月  │YEAR,MONTH                                              │
│景详细评估   ├──────┼────────────────────────────────────────────────────────┤
│             │状态标│PRODUCT_STATUS,ORDER_STATUS,IS_DELETE,VIP_FLAG          │
│             │志    │                                                        │
│             ├──────┼────────────────────────────────────────────────────────┤
│             │类型  │ORDER_TYPE,IMAGE_TYPE,GENDER,CURRENCY_TYPE              │
│             ├──────┼────────────────────────────────────────────────────────┤
│             │区域  │COUNTRY,PROVINCE,CITY                                   │
│             ├──────┼────────────────────────────────────────────────────────┤
│             │操作人│CREATOR,AUDITOR                                         │
│             │员    │                                                        │
│             ├──────┼────────────────────────────────────────────────────────┤
│             │数值  │LEVEL,AMOUNT,SCORE                                      │
│             ├──────┼────────────────────────────────────────────────────────┤
│             │长字符│ADDRESS,COMPANY_NAME,SUMMARY,SUBJECT                    │
├─────────────┼──────┼────────────────────────────────────────────────────────┤
│不适合建索引 │描述备│DESCRIPTION,REMARK,MEMO,DETAIL                          │
│的字段       │注    │                                                        │
│             ├──────┼────────────────────────────────────────────────────────┤
│             │大字段│FILE_CONTENT,EMAIL_CONTENT                              │
└─────────────┴──────┴────────────────────────────────────────────────────────┘

 

如何知道SQL是否使用了正确的索引？

简单SQL可以根据索引使用语法规则判断，复杂的SQL不好办，判断SQL的响应时间是一种策
略，但是这会受到数据量、主机负载及缓存等因素的影响，有时数据全在缓存里，可能全
表访问的时间比索引访问时间还少。要准确知道索引是否正确使用，需要到数据库中查看
SQL真实的执行计划，这个话题比较复杂，详见SQL执行计划专题介绍。

 

索引对DML(INSERT,UPDATE,DELETE)附加的开销有多少？

这个没有固定的比例，与每个表记录的大小及索引字段大小密切相关，以下是一个普通表
测试数据，仅供参考：

索引对于Insert性能降低56%

索引对于Update性能降低47%

索引对于Delete性能降低29%

因此对于写IO压力比较大的系统，表的索引需要仔细评估必要性，另外索引也会占用一定
的存储空间。

 

1.2、只通过索引访问数据

有些时候，我们只是访问表中的几个字段，并且字段内容较少，我们可以为这几个字段单
独建立一个组合索引，这样就可以直接只通过访问索引就能得到数据，一般索引占用的磁
盘空间比表小很多，所以这种方式可以大大减少磁盘IO开销。

如：select id,name from company where type='2';

如果这个SQL经常使用，我们可以在type,id,name上创建组合索引

create index my_comb_index on company(type,id,name);

有了这个组合索引后，SQL就可以直接通过my_comb_index索引返回数据，不需要访问
company表。

还是拿字典举例：有一个需求，需要查询一本汉语字典中所有汉字的个数，如果我们的字
典没有目录索引，那我们只能从字典内容里一个一个字计数，最后返回结果。如果我们有
一个拼音目录，那就可以只访问拼音目录的汉字进行计数。如果一本字典有1000页，拼音
目录有20页，那我们的数据访问成本相当于全表访问的50分之一。

切记，性能优化是无止境的，当性能可以满足需求时即可，不要过度优化。在实际数据库
中我们不可能把每个SQL请求的字段都建在索引里，所以这种只通过索引访问数据的方法一
般只用于核心应用，也就是那种对核心表访问量最高且查询字段数据量很少的查询。

1.3、优化SQL执行计划

SQL执行计划是关系型数据库最核心的技术之一，它表示SQL执行时的数据访问算法。由于
业务需求越来越复杂，表数据量也越来越大，程序员越来越懒惰，SQL也需要支持非常复杂
的业务逻辑，但SQL的性能还需要提高，因此，优秀的关系型数据库除了需要支持复杂的
SQL语法及更多函数外，还需要有一套优秀的算法库来提高SQL性能。

目前ORACLE有SQL执行计划的算法约300种，而且一直在增加，所以SQL执行计划是一个非常
复杂的课题，一个普通DBA能掌握50种就很不错了，就算是资深DBA也不可能把每个执行计
划的算法描述清楚。虽然有这么多种算法，但并不表示我们无法优化执行计划，因为我们
常用的SQL执行计划算法也就十几个，如果一个程序员能把这十几个算法搞清楚，那就掌握
了80%的SQL执行计划调优知识。

由于篇幅的原因，SQL执行计划需要专题介绍，在这里就不多说了。

 

2、返回更少的数据

2.1、数据分页处理

一般数据分页方式有：

2.1.1、客户端(应用程序或浏览器)分页

将数据从应用服务器全部下载到本地应用程序或浏览器，在应用程序或浏览器内部通过本
地代码进行分页处理

优点：编码简单，减少客户端与应用服务器网络交互次数

缺点：首次交互时间长，占用客户端内存

适应场景：客户端与应用服务器网络延时较大，但要求后续操作流畅，如手机GPRS，超远
程访问（跨国）等等。

2.1.2、应用服务器分页

将数据从数据库服务器全部下载到应用服务器，在应用服务器内部再进行数据筛选。以下
是一个应用服务器端Java程序分页的示例：

List list=executeQuery(“select * from employee order by id”);

Int count= list.size();

List subList= list.subList(10, 20);

 

优点：编码简单，只需要一次SQL交互，总数据与分页数据差不多时性能较好。

缺点：总数据量较多时性能较差。

适应场景：数据库系统不支持分页处理，数据量较小并且可控。

 

2.1.3、数据库SQL分页

采用数据库SQL分页需要两次SQL完成

一个SQL计算总数量

一个SQL返回分页后的数据

优点：性能好

缺点：编码复杂，各种数据库语法不同，需要两次SQL交互。

 

oracle数据库一般采用rownum来进行分页，常用分页语法有如下两种：

 

直接通过rownum分页：

select * from (

         select a.*,rownum rn from

                   (select * from product a where company_id=? order by status)
a

         where rownum<=20)

where rn>10;

数据访问开销=索引IO+索引全部记录结果对应的表数据IO

 

采用rowid分页语法

优化原理是通过纯索引找出分页记录的ROWID，再通过ROWID回表返回数据，要求内层查询
和排序字段全在索引里。

create index myindex on product(company_id,status);

 

select b.* from (

         select * from (

                   select a.*,rownum rn from

                            (select rowid rid,status from product a where
company_id=? order by status) a

                   where rownum<=20)

         where rn>10) a, product b

where a.rid=b.rowid;

数据访问开销=索引IO+索引分页结果对应的表数据IO

 

实例：

一个公司产品有1000条记录，要分页取其中20个产品，假设访问公司索引需要50个IO，2条
记录需要1个表数据IO。

那么按第一种ROWNUM分页写法，需要550(50+1000/2)个IO，按第二种ROWID分页写法，只需
要60个IO(50+20/2);

 

2.2、只返回需要的字段

通过去除不必要的返回字段可以提高性能，例：

调整前：select * from product where company_id=?;

调整后：select id,name from product where company_id=?;

 

优点：

1、减少数据在网络上传输开销

2、减少服务器数据处理开销

3、减少客户端内存占用

4、字段变更时提前发现问题，减少程序BUG

5、如果访问的所有字段刚好在一个索引里面，则可以使用纯索引访问提高性能。

缺点：增加编码工作量

由于会增加一些编码工作量，所以一般需求通过开发规范来要求程序员这么做，否则等项
目上线后再整改工作量更大。

如果你的查询表中有大字段或内容较多的字段，如备注信息、文件内容等等，那在查询表
时一定要注意这方面的问题，否则可能会带来严重的性能问题。如果表经常要查询并且请
求大内容字段的概率很低，我们可以采用分表处理，将一个大表分拆成两个一对一的关系
表，将不常用的大内容字段放在一张单独的表中。如一张存储上传文件的表：

T_FILE（ID,FILE_NAME,FILE_SIZE,FILE_TYPE,FILE_CONTENT）

我们可以分拆成两张一对一的关系表：

T_FILE（ID,FILE_NAME,FILE_SIZE,FILE_TYPE）

T_FILECONTENT（ID, FILE_CONTENT）

         通过这种分拆，可以大大提少T_FILE表的单条记录及总大小，这样在查询T_FILE
时性能会更好，当需要查询FILE_CONTENT字段内容时再访问T_FILECONTENT表。

 

3、减少交互次数

3.1、batch DML

数据库访问框架一般都提供了批量提交的接口，jdbc支持batch的提交处理方法，当你一次
性要往一个表中插入1000万条数据时，如果采用普通的executeUpdate处理，那么和服务器
交互次数为1000万次，按每秒钟可以向数据库服务器提交10000次估算，要完成所有工作需
要1000秒。如果采用批量提交模式，1000条提交一次，那么和服务器交互次数为1万次，交
互次数大大减少。采用batch操作一般不会减少很多数据库服务器的物理IO，但是会大大减
少客户端与服务端的交互次数，从而减少了多次发起的网络延时开销，同时也会降低数据
库的CPU开销。

 

假设要向一个普通表插入1000万数据，每条记录大小为1K字节，表上没有任何索引，客户
端与数据库服务器网络是100Mbps，以下是根据现在一般计算机能力估算的各种batch大小
性能对比值：

 

┌────────────────────┬────────┬────────┬─────────┬──────────┬───────────┐
│　单位：ms          │No batch│Batch=10│Batch=100│Batch=1000│Batch=10000│
├────────────────────┼────────┼────────┼─────────┼──────────┼───────────┤
│服务器事务处理时间  │     0.1│     0.1│      0.1│       0.1│        0.1│
├────────────────────┼────────┼────────┼─────────┼──────────┼───────────┤
│服务器IO处理时间    │    0.02│     0.2│        2│        20│        200│
├────────────────────┼────────┼────────┼─────────┼──────────┼───────────┤
│网络交互发起时间    │     0.1│     0.1│      0.1│       0.1│        0.1│
├────────────────────┼────────┼────────┼─────────┼──────────┼───────────┤
│网络数据传输时间    │    0.01│     0.1│        1│        10│        100│
├────────────────────┼────────┼────────┼─────────┼──────────┼───────────┤
│小计                │    0.23│     0.5│      3.2│      30.2│      300.2│
├────────────────────┼────────┼────────┼─────────┼──────────┼───────────┤
│平均每条记录处理时间│    0.23│    0.05│    0.032│    0.0302│    0.03002│
└────────────────────┴────────┴────────┴─────────┴──────────┴───────────┘

 

从上可以看出，Insert操作加大Batch可以对性能提高近8倍性能，一般根据主键的Update
或Delete操作也可能提高2-3倍性能，但不如Insert明显，因为Update及Delete操作可能有
比较大的开销在物理IO访问。以上仅是理论计算值，实际情况需要根据具体环境测量。

 

3.2、In List

很多时候我们需要按一些ID查询数据库记录，我们可以采用一个ID一个请求发给数据库，
如下所示：

for :var in ids[] do begin

  select * from mytable where id=:var;

end;

 

我们也可以做一个小的优化， 如下所示，用ID INLIST的这种方式写SQL：

select * from mytable where id in(:id1,id2,...,idn);

 

通过这样处理可以大大减少SQL请求的数量，从而提高性能。那如果有10000个ID，那是不
是全部放在一条SQL里处理呢？答案肯定是否定的。首先大部份数据库都会有SQL长度和IN
里个数的限制，如ORACLE的IN里就不允许超过1000个值。

另外当前数据库一般都是采用基于成本的优化规则，当IN数量达到一定值时有可能改变SQL
执行计划，从索引访问变成全表访问，这将使性能急剧变化。随着SQL中IN的里面的值个数
增加，SQL的执行计划会更复杂，占用的内存将会变大，这将会增加服务器CPU及内存成本
。

评估在IN里面一次放多少个值还需要考虑应用服务器本地内存的开销，有并发访问时要计
算本地数据使用周期内的并发上限，否则可能会导致内存溢出。

综合考虑，一般IN里面的值个数超过20个以后性能基本没什么太大变化，也特别说明不要
超过100，超过后可能会引起执行计划的不稳定性及增加数据库CPU及内存成本，这个需要
专业DBA评估。

 

3.3、设置Fetch Size

当我们采用select从数据库查询数据时，数据默认并不是一条一条返回给客户端的，也不
是一次全部返回客户端的，而是根据客户端fetch_size参数处理，每次只返回fetch_size
条记录，当客户端游标遍历到尾部时再从服务端取数据，直到最后全部传送完成。所以如
果我们要从服务端一次取大量数据时，可以加大fetch_size，这样可以减少结果数据传输
的交互次数及服务器数据准备时间，提高性能。

 

以下是jdbc测试的代码，采用本地数据库，表缓存在数据库CACHE中，因此没有网络连接及
磁盘IO开销，客户端只遍历游标，不做任何处理，这样更能体现fetch参数的影响：

String vsql ="select * from t_employee";

PreparedStatement pstmt = conn.prepareStatement
(vsql,ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);

pstmt.setFetchSize(1000);

ResultSet rs = pstmt.executeQuery(vsql);

int cnt = rs.getMetaData().getColumnCount();

Object o;

while (rs.next()) {

    for (int i = 1; i <= cnt; i++) {

       o = rs.getObject(i);

    }

}

 

测试示例中的employee表有100000条记录，每条记录平均长度135字节

 

以下是测试结果，对每种fetchsize测试5次再取平均值：

fetchsize  elapse_time（s）

        1             20.516

        2              11.34

        4              6.894

        8               4.65

       16              3.584

       32              2.865

       64              2.656

      128               2.44

      256              2.765

      512              3.075

     1024              2.862

     2048              2.722

     4096              2.681

     8192              2.715


 

 

[0_12916366] 

Oracle jdbc fetchsize默认值为10，由上测试可以看出fetchsize对性能影响还是比较大
的，但是当fetchsize大于100时就基本上没有影响了。fetchsize并不会存在一个最优的固
定值，因为整体性能与记录集大小及硬件平台有关。根据测试结果建议当一次性要取大量
数据时这个值设置为100左右，不要小于40。注意，fetchsize不能设置太大，如果一次取
出的数据大于JVM的内存会导致内存溢出，所以建议不要超过1000，太大了也没什么性能提
高，反而可能会增加内存溢出的危险。

注：图中fetchsize在128以后会有一些小的波动，这并不是测试误差，而是由于resultset
填充到具体对像时间不同的原因，由于resultset已经到本地内存里了，所以估计是由于
CPU的L1,L2 Cache命中率变化造成，由于变化不大，所以笔者也未深入分析原因。

 

iBatis的SqlMapping配置文件可以对每个SQL语句指定fetchsize大小，如下所示：

 

<select id="getAllProduct" resultMap="HashMap" fetchSize="1000">

select * from employee

</select>

 

3.4、使用存储过程

大型数据库一般都支持存储过程，合理的利用存储过程也可以提高系统性能。如你有一个
业务需要将A表的数据做一些加工然后更新到B表中，但是又不可能一条SQL完成，这时你需
要如下3步操作：

a：将A表数据全部取出到客户端；

b：计算出要更新的数据；

c：将计算结果更新到B表。

 

如果采用存储过程你可以将整个业务逻辑封装在存储过程里，然后在客户端直接调用存储
过程处理，这样可以减少网络交互的成本。

当然，存储过程也并不是十全十美，存储过程有以下缺点：

a、不可移植性，每种数据库的内部编程语法都不太相同，当你的系统需要兼容多种数据库
时最好不要用存储过程。

b、学习成本高，DBA一般都擅长写存储过程，但并不是每个程序员都能写好存储过程，除
非你的团队有较多的开发人员熟悉写存储过程，否则后期系统维护会产生问题。

c、业务逻辑多处存在，采用存储过程后也就意味着你的系统有一些业务逻辑不是在应用程
序里处理，这种架构会增加一些系统维护和调试成本。

d、存储过程和常用应用程序语言不一样，它支持的函数及语法有可能不能满足需求，有些
逻辑就只能通过应用程序处理。

e、如果存储过程中有复杂运算的话，会增加一些数据库服务端的处理成本，对于集中式数
据库可能会导致系统可扩展性问题。

f、为了提高性能，数据库会把存储过程代码编译成中间运行代码(类似于java的class文
件)，所以更像静态语言。当存储过程引用的对像(表、视图等等)结构改变后，存储过程需
要重新编译才能生效，在24*7高并发应用场景，一般都是在线变更结构的，所以在变更的
瞬间要同时编译存储过程，这可能会导致数据库瞬间压力上升引起故障(Oracle数据库就存
在这样的问题)。

 

个人观点：普通业务逻辑尽量不要使用存储过程，定时性的ETL任务或报表统计函数可以根
据团队资源情况采用存储过程处理。

 

3.5、优化业务逻辑

要通过优化业务逻辑来提高性能是比较困难的，这需要程序员对所访问的数据及业务流程
非常清楚。

举一个案例：

某移动公司推出优惠套参，活动对像为VIP会员并且2010年1，2，3月平均话费20元以上的
客户。

那我们的检测逻辑为：

select avg(money) as avg_money from bill where phone_no='13988888888' and date
between '201001' and '201003';

select vip_flag from member where phone_no='13988888888';

if avg_money>20 and vip_flag=true then

begin

  执行套参();

end;

 

如果我们修改业务逻辑为:

select avg(money) as  avg_money from bill where phone_no='13988888888' and date
between '201001' and '201003';

if avg_money>20 then

begin

  select vip_flag from member where phone_no='13988888888';

  if vip_flag=true then

  begin

    执行套参();

  end;

end;

通过这样可以减少一些判断vip_flag的开销，平均话费20元以下的用户就不需要再检测是
否VIP了。

 

如果程序员分析业务，VIP会员比例为1%，平均话费20元以上的用户比例为90%，那我们改
成如下：

select vip_flag from member where phone_no='13988888888';

if vip_flag=true then

begin

  select avg(money) as avg_money from bill where phone_no='13988888888' and
date between '201001' and '201003';

  if avg_money>20 then

  begin

    执行套参();

  end;

end;

这样就只有1%的VIP会员才会做检测平均话费，最终大大减少了SQL的交互次数。

 

以上只是一个简单的示例，实际的业务总是比这复杂得多，所以一般只是高级程序员更容
易做出优化的逻辑，但是我们需要有这样一种成本优化的意识。

 

3.6、使用ResultSet游标处理记录

现在大部分Java框架都是通过jdbc从数据库取出数据，然后装载到一个list里再处理，
list里可能是业务Object，也可能是hashmap。

由于JVM内存一般都小于4G，所以不可能一次通过sql把大量数据装载到list里。为了完成
功能，很多程序员喜欢采用分页的方法处理，如一次从数据库取1000条记录，通过多次循
环搞定，保证不会引起JVM Out of memory问题。

 

以下是实现此功能的代码示例，t_employee表有10万条记录，设置分页大小为1000：

 

d1 = Calendar.getInstance().getTime();

vsql = "select count(*) cnt from t_employee";

pstmt = conn.prepareStatement(vsql);

ResultSet rs = pstmt.executeQuery();

Integer cnt = 0;

while (rs.next()) {

         cnt = rs.getInt("cnt");

}

Integer lastid=0;

Integer pagesize=1000;

System.out.println("cnt:" + cnt);

String vsql = "select count(*) cnt from t_employee";

PreparedStatement pstmt = conn.prepareStatement(vsql);

ResultSet rs = pstmt.executeQuery();

Integer cnt = 0;

while (rs.next()) {

         cnt = rs.getInt("cnt");

}

Integer lastid = 0;

Integer pagesize = 1000;

System.out.println("cnt:" + cnt);

for (int i = 0; i <= cnt / pagesize; i++) {

         vsql = "select * from (select * from t_employee where id>? order by
id) where rownum<=?";

         pstmt = conn.prepareStatement(vsql);

         pstmt.setFetchSize(1000);

         pstmt.setInt(1, lastid);

         pstmt.setInt(2, pagesize);

         rs = pstmt.executeQuery();

         int col_cnt = rs.getMetaData().getColumnCount();

         Object o;

         while (rs.next()) {

                   for (int j = 1; j <= col_cnt; j++) {

                            o = rs.getObject(j);

                   }

                   lastid = rs.getInt("id");

         }

         rs.close();

         pstmt.close();

}

 

以上代码实际执行时间为6.516秒

 

很多持久层框架为了尽量让程序员使用方便，封装了jdbc通过statement执行数据返回到
resultset的细节，导致程序员会想采用分页的方式处理问题。实际上如果我们采用jdbc原
始的resultset游标处理记录，在resultset循环读取的过程中处理记录，这样就可以一次
从数据库取出所有记录。显著提高性能。

这里需要注意的是，采用resultset游标处理记录时，应该将游标的打开方式设置为
FORWARD_READONLY模式(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY)，
否则会把结果缓存在JVM里，造成JVM Out of memory问题。

 

代码示例：

 

String vsql ="select * from t_employee";

PreparedStatement pstmt = conn.prepareStatement
(vsql,ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_READ_ONLY);

pstmt.setFetchSize(100);

ResultSet rs = pstmt.executeQuery(vsql);

int col_cnt = rs.getMetaData().getColumnCount();

Object o;

while (rs.next()) {

         for (int j = 1; j <= col_cnt; j++) {

                   o = rs.getObject(j);

         }

}

调整后的代码实际执行时间为3.156秒

 

从测试结果可以看出性能提高了1倍多，如果采用分页模式数据库每次还需发生磁盘IO的话
那性能可以提高更多。

iBatis等持久层框架考虑到会有这种需求，所以也有相应的解决方案，在iBatis里我们不
能采用queryForList的方法，而应用该采用queryWithRowHandler加回调事件的方式处理，
如下所示：

 

MyRowHandler myrh=new MyRowHandler();

sqlmap.queryWithRowHandler("getAllEmployee", myrh);

 

class MyRowHandler implements RowHandler {

    public void handleRow(Object o) {

       //todo something

    }

}

 

iBatis的queryWithRowHandler很好的封装了resultset遍历的事件处理，效果及性能与
resultset遍历一样，也不会产生JVM内存溢出。

 

4、减少数据库服务器CPU运算

4.1、使用绑定变量

绑定变量是指SQL中对变化的值采用变量参数的形式提交，而不是在SQL中直接拼写对应的
值。

非绑定变量写法：Select * from employee where id=1234567

绑定变量写法：

Select * from employee where id=?

Preparestatement.setInt(1,1234567)

 

Java中Preparestatement就是为处理绑定变量提供的对像，绑定变量有以下优点：

1、防止SQL注入

2、提高SQL可读性

3、提高SQL解析性能，不使用绑定变更我们一般称为硬解析，使用绑定变量我们称为软解
析。

第1和第2点很好理解，做编码的人应该都清楚，这里不详细说明。关于第3点，到底能提高
多少性能呢，下面举一个例子说明：

 

假设有这个这样的一个数据库主机：

2个4核CPU 

100块磁盘，每个磁盘支持IOPS为160

业务应用的SQL如下：

select * from table where pk=?

这个SQL平均4个IO（3个索引IO+1个数据IO）

IO缓存命中率75%（索引全在内存中，数据需要访问磁盘）

SQL硬解析CPU消耗：1ms  （常用经验值）

SQL软解析CPU消耗：0.02ms（常用经验值）

 

假设CPU每核性能是线性增长，访问内存Cache中的IO时间忽略，要求计算系统对如上应用
采用硬解析与采用软解析支持的每秒最大并发数：

 

┌────────────────┬────────────────────┬────────────────────┐
│是否使用绑定变量│CPU支持最大并发数   │磁盘IO支持最大并发数│
├────────────────┼────────────────────┼────────────────────┤
│不使用          │2*4*1000=8000       │100*160=16000       │
├────────────────┼────────────────────┼────────────────────┤
│使用            │2*4*1000/0.02=400000│100*160=16000       │
└────────────────┴────────────────────┴────────────────────┘

 

从以上计算可以看出，不使用绑定变量的系统当并发达到8000时会在CPU上产生瓶颈，当使
用绑定变量的系统当并行达到16000时会在磁盘IO上产生瓶颈。所以如果你的系统CPU有瓶
颈时请先检查是否存在大量的硬解析操作。

 

使用绑定变量为何会提高SQL解析性能，这个需要从数据库SQL执行原理说明，一条SQL在
Oracle数据库中的执行过程如下图所示：

 

 

[0_12916366] 

当一条SQL发送给数据库服务器后，系统首先会将SQL字符串进行hash运算，得到hash值后
再从服务器内存里的SQL缓存区中进行检索，如果有相同的SQL字符，并且确认是同一逻辑
的SQL语句，则从共享池缓存中取出SQL对应的执行计划，根据执行计划读取数据并返回结
果给客户端。

如果在共享池中未发现相同的SQL则根据SQL逻辑生成一条新的执行计划并保存在SQL缓存区
中，然后根据执行计划读取数据并返回结果给客户端。

为了更快的检索SQL是否在缓存区中，首先进行的是SQL字符串hash值对比，如果未找到则
认为没有缓存，如果存在再进行下一步的准确对比，所以要命中SQL缓存区应保证SQL字符
是完全一致，中间有大小写或空格都会认为是不同的SQL。

如果我们不采用绑定变量，采用字符串拼接的模式生成SQL,那么每条SQL都会产生执行计划
，这样会导致共享池耗尽，缓存命中率也很低。

 

一些不使用绑定变量的场景：

a、数据仓库应用，这种应用一般并发不高，但是每个SQL执行时间很长，SQL解析的时间相
比SQL执行时间比较小，绑定变量对性能提高不明显。数据仓库一般都是内部分析应用，所
以也不太会发生SQL注入的安全问题。

b、数据分布不均匀的特殊逻辑，如产品表，记录有1亿，有一产品状态字段，上面建有索
引，有审核中，审核通过，审核未通过3种状态，其中审核通过9500万，审核中1万，审核
不通过499万。

要做这样一个查询：

select count(*) from product where status=?

采用绑定变量的话，那么只会有一个执行计划，如果走索引访问，那么对于审核中查询很
快，对审核通过和审核不通过会很慢；如果不走索引，那么对于审核中与审核通过和审核
不通过时间基本一样；

对于这种情况应该不使用绑定变量，而直接采用字符拼接的方式生成SQL，这样可以为每个
SQL生成不同的执行计划，如下所示。

select count(*) from product where status='approved'; //不使用索引

select count(*) from product where status='tbd'; //不使用索引

select count(*) from product where status='auditing';//使用索引

 

4.2、合理使用排序

Oracle的排序算法一直在优化，但是总体时间复杂度约等于nLog(n)。普通OLTP系统排序操
作一般都是在内存里进行的，对于数据库来说是一种CPU的消耗，曾在PC机做过测试，单核
普通CPU在1秒钟可以完成100万条记录的全内存排序操作，所以说由于现在CPU的性能增强
，对于普通的几十条或上百条记录排序对系统的影响也不会很大。但是当你的记录集增加
到上万条以上时，你需要注意是否一定要这么做了，大记录集排序不仅增加了CPU开销，而
且可能会由于内存不足发生硬盘排序的现象，当发生硬盘排序时性能会急剧下降，这种需
求需要与DBA沟通再决定，取决于你的需求和数据，所以只有你自己最清楚，而不要被别人
说排序很慢就吓倒。

以下列出了可能会发生排序操作的SQL语法：

Order by

Group by

Distinct

Exists子查询

Not Exists子查询

In子查询

Not In子查询

Union（并集），Union All也是一种并集操作，但是不会发生排序，如果你确认两个数据
集不需要执行去除重复数据操作，那请使用Union All 代替Union。

Minus（差集）

Intersect（交集）

Create Index

Merge Join，这是一种两个表连接的内部算法，执行时会把两个表先排序好再连接，应用
于两个大表连接的操作。如果你的两个表连接的条件都是等值运算，那可以采用Hash Join
来提高性能，因为Hash Join使用Hash 运算来代替排序的操作。具体原理及设置参考SQL执
行计划优化专题。

 

4.3、减少比较操作

我们SQL的业务逻辑经常会包含一些比较操作，如a=b，a<b之类的操作，对于这些比较操作
数据库都体现得很好，但是如果有以下操作，我们需要保持警惕：

Like模糊查询，如下所示：

a like ‘%abc%’

 

Like模糊查询对于数据库来说不是很擅长，特别是你需要模糊检查的记录有上万条以上时
，性能比较糟糕，这种情况一般可以采用专用Search或者采用全文索引方案来提高性能。

不能使用索引定位的大量In List，如下所示：

a in (:1,:2,:3,…,:n)   ----n>20

如果这里的a字段不能通过索引比较，那数据库会将字段与in里面的每个值都进行比较运算
，如果记录数有上万以上，会明显感觉到SQL的CPU开销加大，这个情况有两种解决方式：

a、  将in列表里面的数据放入一张中间小表，采用两个表Hash Join关联的方式处理；

b、  采用str2varList方法将字段串列表转换一个临时表处理，关于str2varList方法可以
在网上直接查询，这里不详细介绍。

 

以上两种解决方案都需要与中间表Hash Join的方式才能提高性能，如果采用了Nested
Loop的连接方式性能会更差。

如果发现我们的系统IO没问题但是CPU负载很高，就有可能是上面的原因，这种情况不太常
见，如果遇到了最好能和DBA沟通并确认准确的原因。

 

4.4、大量复杂运算在客户端处理

什么是复杂运算，一般我认为是一秒钟CPU只能做10万次以内的运算。如含小数的对数及指
数运算、三角函数、3DES及BASE64数据加密算法等等。

如果有大量这类函数运算，尽量放在客户端处理，一般CPU每秒中也只能处理1万-10万次这
样的函数运算，放在数据库内不利于高并发处理。

 

5、利用更多的资源

5.1、客户端多进程并行访问

多进程并行访问是指在客户端创建多个进程(线程)，每个进程建立一个与数据库的连接，
然后同时向数据库提交访问请求。当数据库主机资源有空闲时，我们可以采用客户端多进
程并行访问的方法来提高性能。如果数据库主机已经很忙时，采用多进程并行访问性能不
会提高，反而可能会更慢。所以使用这种方式最好与DBA或系统管理员进行沟通后再决定是
否采用。

 

例如：

我们有10000个产品ID，现在需要根据ID取出产品的详细信息，如果单线程访问，按每个IO
要5ms计算，忽略主机CPU运算及网络传输时间，我们需要50s才能完成任务。如果采用5个
并行访问，每个进程访问2000个ID，那么10s就有可能完成任务。

那是不是并行数越多越好呢，开1000个并行是否只要50ms就搞定，答案肯定是否定的，当
并行数超过服务器主机资源的上限时性能就不会再提高，如果再增加反而会增加主机的进
程间调度成本和进程冲突机率。

 

以下是一些如何设置并行数的基本建议：

如果瓶颈在服务器主机，但是主机还有空闲资源，那么最大并行数取主机CPU核数和主机提
供数据服务的磁盘数两个参数中的最小值，同时要保证主机有资源做其它任务。

如果瓶颈在客户端处理，但是客户端还有空闲资源，那建议不要增加SQL的并行，而是用一
个进程取回数据后在客户端起多个进程处理即可，进程数根据客户端CPU核数计算。

如果瓶颈在客户端网络，那建议做数据压缩或者增加多个客户端，采用map reduce的架构
处理。

如果瓶颈在服务器网络，那需要增加服务器的网络带宽或者在服务端将数据压缩后再处理
了。

 

5.2、数据库并行处理

数据库并行处理是指客户端一条SQL的请求，数据库内部自动分解成多个进程并行处理，如
下图所示：

 

[0_12916366] 

并不是所有的SQL都可以使用并行处理，一般只有对表或索引进行全部访问时才可以使用并
行。数据库表默认是不打开并行访问，所以需要指定SQL并行的提示，如下所示：

select /*+parallel(a,4)*/ * from employee;

 

并行的优点：

使用多进程处理，充分利用数据库主机资源（CPU,IO），提高性能。

并行的缺点：

1、单个会话占用大量资源，影响其它会话，所以只适合在主机负载低时期使用；

2、只能采用直接IO访问，不能利用缓存数据，所以执行前会触发将脏缓存数据写入磁盘操
作。

 

注：

1、并行处理在OLTP类系统中慎用，使用不当会导致一个会话把主机资源全部占用，而正常
事务得不到及时响应，所以一般只是用于数据仓库平台。

2、一般对于百万级记录以下的小表采用并行访问性能并不能提高，反而可能会让性能更差
。


SQL性能优化  --- 面试题

今天面试，我简历上写了熟悉sql的性能优化，但是今天面试，一时想不起别的，就仅仅说
出了一条，在这里再总结一些，完善自己的知识点。

我经常用的数据库是oracle，所以我的sql优化是程序员针对于oracle的。

[SouthEast]

总结，这个sql优化是针对程序员的，而不是针对dba的，主要就是第一，尽量防止模糊，
明确指出，即用列名代替*，第二，在where语句上下工夫。第三多表查询和子查询，第四
尽量使用绑定。



数据库性能优化之SQL语句优化1

一、问题的提出

在应用系统开发初期，由于开发数据库数据比较少，对于查询SQL语句，复杂视图的的编写
等体会不出SQL语句各种写法的性能优劣，但是如果将应用系统提交实际应用后，随着数据
库中数据的增加，系统的响应速度就成为目前系统需要解决的最主要的问题之一。系统优
化中一个很重要的方面就是SQL语句的优化。对于海量数据，劣质SQL语句和优质SQL语句之
间的速度差别可以达到上百倍，可见对于一个系统不是简单地能实现其功能就可，而是要
写出高质量的SQL语句，提高系统的可用性。

在多数情况下，Oracle使用索引来更快地遍历表，优化器主要根据定义的索引来提高性能
。但是，如果在SQL语句的where子句中写的SQL代码不合理，就会造成优化器删去索引而使
用全表扫描，一般就这种SQL语句就是所谓的劣质SQL语句。在编写SQL语句时我们应清楚优
化器根据何种原则来删除索引，这有助于写出高性能的SQL语句。

二、SQL语句编写注意问题

下面就某些SQL语句的where子句编写中需要注意的问题作详细介绍。在这些where子句中，
即使某些列存在索引，但是由于编写了劣质的SQL，系统在运行该SQL语句时也不能使用该
索引，而同样使用全表扫描，这就造成了响应速度的极大降低。

1. 操作符优化

(a) IN 操作符

用IN写出来的SQL的优点是比较容易写及清晰易懂，这比较适合现代软件开发的风格。但是
用IN的SQL性能总是比较低的，从Oracle执行的步骤来分析用IN的SQL与不用IN的SQL有以下
区别：

ORACLE试图将其转换成多个表的连接，如果转换不成功则先执行IN里面的子查询，再查询
外层的表记录，如果转换成功则直接采用多个表的连接方式查询。由此可见用IN的SQL至少
多了一个转换的过程。一般的SQL都可以转换成功，但对于含有分组统计等方面的SQL就不
能转换了。

推荐方案：在业务密集的SQL当中尽量不采用IN操作符，用EXISTS 方案代替。

(b) NOT IN操作符

此操作是强列不推荐使用的，因为它不能应用表的索引。

推荐方案：用NOT EXISTS 方案代替

(c) IS NULL 或IS NOT NULL操作（判断字段是否为空）

判断字段是否为空一般是不会应用索引的，因为索引是不索引空值的。不能用null作索引
，任何包含null值的列都将不会被包含在索引中。即使索引有多列这样的情况下，只要这
些列中有一列含有null，该列就会从索引中排除。也就是说如果某列存在空值，即使对该
列建索引也不会提高性能。任何在where子句中使用is null或is not null的语句优化器是
不允许使用索引的。

推荐方案：用其它相同功能的操作运算代替，如：a is not null 改为 a>0 或a>’’等。不
允许字段为空，而用一个缺省值代替空值，如申请中状态字段不允许为空，缺省为申请。

(d) > 及 < 操作符（大于或小于操作符）

大于或小于操作符一般情况下是不用调整的，因为它有索引就会采用索引查找，但有的情
况下可以对它进行优化，如一个表有100万记录，一个数值型字段A，30万记录的A=0，30万
记录的A=1，39万记录的A=2，1万记录的A=3。那么执行A>2与A>=3的效果就有很大的区别了
，因为A>2时ORACLE会先找出为2的记录索引再进行比较，而A>=3时ORACLE则直接找到=3的
记录索引。

(e) LIKE操作符

LIKE操作符可以应用通配符查询，里面的通配符组合可能达到几乎是任意的查询，但是如
果用得不好则会产生性能上的问题，如LIKE ‘%5400%’ 这种查询不会引用索引，而LIKE
‘X5400%’则会引用范围索引。

一个实际例子：用YW_YHJBQK表中营业编号后面的户标识号可来查询营业编号 YY_BH LIKE
‘%5400%’ 这个条件会产生全表扫描，如果改成YY_BH LIKE ’X5400%’ OR YY_BH LIKE
’B5400%’ 则会利用YY_BH的索引进行两个范围的查询，性能肯定大大提高。

带通配符(%)的like语句：

同样以上面的例子来看这种情况。目前的需求是这样的，要求在职工表中查询名字中包含
cliton的人。可以采用如下的查询SQL语句:

select * from employee where last_name like '%cliton%';

这里由于通配符(%)在搜寻词首出现，所以Oracle系统不使用last_name的索引。在很多情
况下可能无法避免这种情况，但是一定要心中有底，通配符如此使用会降低查询速度。然
而当通配符出现在字符串其他位置时，优化器就能利用索引。在下面的查询中索引得到了
使用:

select * from employee where last_name like 'c%';

(f) UNION操作符

UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序
运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的
是过程表与历史表UNION。如： 
select * from gc_dfys 
union 
select * from ls_jg_dfys 
这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回
结果集，如果表数据量大的话可能会导致用磁盘进行排序。

推荐方案：采用UNION ALL操作符替代UNION，因为UNION ALL操作只是简单的将两个结果合
并后就返回。

select * from gc_dfys 
union all 
select * from ls_jg_dfys

(g) 联接列

对于有联接的列，即使最后的联接值为一个静态值，优化器是不会使用索引的。我们一起
来看一个例子，假定有一个职工表(employee)，对于一个职工的姓和名分成两列存放
(FIRST_NAME和LAST_NAME)，现在要查询一个叫比尔.克林顿(Bill Cliton)的职工。

下面是一个采用联接查询的SQL语句：

select * from employss where first_name||''||last_name ='Beill Cliton';

上面这条语句完全可以查询出是否有Bill Cliton这个员工，但是这里需要注意，系统优化
器对基于last_name创建的索引没有使用。当采用下面这种SQL语句的编写，Oracle系统就
可以采用基于last_name创建的索引。

*** where first_name ='Beill' and last_name ='Cliton';

(h) Order by语句

ORDER BY语句决定了Oracle如何将返回的查询结果排序。Order by语句对要排序的列没有
什么特别的限制，也可以将函数加入列中(象联接或者附加等)。任何在Order by语句的非
索引项或者有计算表达式都将降低查询速度。

仔细检查order by语句以找出非索引项或者表达式，它们会降低性能。解决这个问题的办
法就是重写order by语句以使用索引，也可以为所使用的列建立另外一个索引，同时应绝
对避免在order by子句中使用表达式。

(i) NOT

我们在查询时经常在where子句使用一些逻辑表达式，如大于、小于、等于以及不等于等等
，也可以使用and(与)、or(或)以及not(非)。NOT可用来对任何逻辑运算符号取反。下面是
一个NOT子句的例子:

... where not (status ='VALID')

如果要使用NOT，则应在取反的短语前面加上括号，并在短语前面加上NOT运算符。NOT运算
符包含在另外一个逻辑运算符中，这就是不等于(<>)运算符。换句话说，即使不在查询
where子句中显式地加入NOT词，NOT仍在运算符中，见下例:

... where status <>'INVALID';

对这个查询，可以改写为不使用NOT：

select * from employee where salary<3000 or salary>3000;

虽然这两种查询的结果一样，但是第二种查询方案会比第一种查询方案更快些。第二种查
询允许Oracle对salary列使用索引，而第一种查询则不能使用索引。

2. SQL书写的影响

(a) 同一功能同一性能不同写法SQL的影响。

如一个SQL在A程序员写的为  Select * from zl_yhjbqk

B程序员写的为 Select * from dlyx.zl_yhjbqk（带表所有者的前缀）

C程序员写的为 Select * from DLYX.ZLYHJBQK（大写表名）

D程序员写的为 Select *  from DLYX.ZLYHJBQK（中间多了空格）

以上四个SQL在ORACLE分析整理之后产生的结果及执行的时间是一样的，但是从ORACLE共享
内存SGA的原理，可以得出ORACLE对每个SQL 都会对其进行一次分析，并且占用共享内存，
如果将SQL的字符串及格式写得完全相同，则ORACLE只会分析一次，共享内存也只会留下一
次的分析结果，这不仅可以减少分析SQL的时间，而且可以减少共享内存重复的信息，
ORACLE也可以准确统计SQL的执行频率。

(b) WHERE后面的条件顺序影响

WHERE子句后面的条件顺序对大数据量表的查询会产生直接的影响。如： 
Select * from zl_yhjbqk where dy_dj = '1KV以下' and xh_bz=1 
Select * from zl_yhjbqk where xh_bz=1 and dy_dj = '1KV以下' 
以上两个SQL中dy_dj（电压等级）及xh_bz（销户标志）两个字段都没进行索引，所以执行
的时候都是全表扫描，第一条SQL的dy_dj = '1KV以下'条件在记录集内比率为99%，而
xh_bz=1的比率只为0.5%，在进行第一条SQL的时候99%条记录都进行dy_dj及xh_bz的比较，
而在进行第二条SQL的时候0.5%条记录都进行dy_dj及xh_bz的比较，以此可以得出第二条
SQL的CPU占用率明显比第一条低。

(c) 查询表顺序的影响

在FROM后面的表中的列表顺序会对SQL执行性能影响，在没有索引及ORACLE没有对表进行统
计分析的情况下，ORACLE会按表出现的顺序进行链接，由此可见表的顺序不对时会产生十
分耗服物器资源的数据交叉。（注：如果对表进行了统计分析，ORACLE会自动先进小表的
链接，再进行大表的链接）

3. SQL语句索引的利用

(a) 对条件字段的一些优化

采用函数处理的字段不能利用索引，如：

substr(hbs_bh,1,4)=’5400’，优化处理：hbs_bh like ‘5400%’

trunc(sk_rq)=trunc(sysdate)，优化处理：sk_rq>=trunc(sysdate) and sk_rq<trunc
(sysdate+1)

进行了显式或隐式的运算的字段不能进行索引，如：ss_df+20>50，优化处理：ss_df>30

‘X’ || hbs_bh>’X5400021452’，优化处理：hbs_bh>’5400021542’

sk_rq+5=sysdate，优化处理：sk_rq=sysdate-5

hbs_bh=5401002554，优化处理：hbs_bh=’ 5401002554’，注：此条件对hbs_bh 进行隐式
的to_number转换，因为hbs_bh字段是字符型。

条件内包括了多个本表的字段运算时不能进行索引，如：

ys_df>cx_df，无法进行优化 
qc_bh || kh_bh=’5400250000’，优化处理：qc_bh=’5400’ and kh_bh=’250000’

4. 更多方面SQL优化资料分享

（1）选择最有效率的表名顺序(只在基于规则的优化器中有效)：

ORACLE 的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表
(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记
录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表
(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表.

（2） WHERE子句中的连接顺序：

ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他
WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾.

（3） SELECT子句中避免使用 ‘ * ‘：

ORACLE在解析的过程中, 会将'*' 依次转换成所有的列名, 这个工作是通过查询数据字典
完成的, 这意味着将耗费更多的时间。

（4）减少访问数据库的次数：

ORACLE在内部执行了许多工作: 解析SQL语句, 估算索引的利用率, 绑定变量 , 读数据块
等。

（5）在SQL*Plus , SQL*Forms和Pro*C中重新设置ARRAYSIZE参数, 可以增加每次数据库访
问的检索数据量 ,建议值为200。

（6）使用DECODE函数来减少处理时间：

使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表.

（7）整合简单,无关联的数据库访问：

如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有
关系) 。

（8）删除重复记录：

最高效的删除重复记录方法 ( 因为使用了ROWID)例子： 
DELETE  FROM  EMP E  WHERE  E.ROWID > (SELECT MIN(X.ROWID) FROM  EMP X  WHERE 
X.EMP_NO = E.EMP_NO)。

（9）用TRUNCATE替代DELETE：

当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复
的信息. 如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复
到执行删除命令之前的状况) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.
当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短. (译者按:
TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML) 。

（10）尽量多使用COMMIT：

只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT
所释放的资源而减少，COMMIT所释放的资源: 
a. 回滚段上用于恢复数据的信息. 
b. 被程序语句获得的锁 
c. redo log buffer 中的空间 
d. ORACLE为管理上述3种资源中的内部花费

（11）用Where子句替换HAVING子句：

避免使用HAVING子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤. 这个处理
需要排序,总计等操作. 如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销.
(非oracle中)on、where、having这三个都可以加条件的子句中，on是最先执行，where次
之，having最后，因为on是先把不符合条件的记录过滤后才进行统计，它就可以减少中间
运算要处理的数据，按理说应该速度是最快的，where也应该比having快点的，因为它过滤
数据后才进行sum，在两个表联接时才用on的，所以在一个表的时候，就剩下where跟
having比较了。在这单表查询统计的情况下，如果要过滤的条件没有涉及到要计算字段，
那它们的结果是一样的，只是where可以使用rushmore技术，而having就不能，在速度上后
者要慢如果要涉及到计算的字段，就表示在没计算之前，这个字段的值是不确定的，根据
上篇写的工作流程，where的作用时间是在计算之前就完成的，而having就是在计算后才起
作用的，所以在这种情况下，两者的结果会不同。在多表联接查询时，on比where更早起作
用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表后，再由where进行过
滤，然后再计算，计算完后再由having进行过滤。由此可见，要想过滤条件起到正确的作
用，首先要明白这个条件应该在什么时候起作用，然后再决定放在那里。

（12）减少对表的查询：

在含有子查询的SQL语句中,要特别注意减少对表的查询.例子： 
SELECT  TAB_NAME FROM TABLES WHERE (TAB_NAME,DB_VER) = ( SELECT TAB_NAME,DB_VER
FROM  TAB_COLUMNS  WHERE  VERSION = 604)

（13）通过内部函数提高SQL效率：

复杂的SQL往往牺牲了执行效率. 能够掌握上面的运用函数解决问题的方法在实际工作中是
非常有意义的。

（14）使用表的别名(Alias)：

当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就
可以减少解析的时间并减少那些由Column歧义引起的语法错误。

（15）用EXISTS替代IN、用NOT EXISTS替代NOT IN：

在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况
下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 在子查询中,NOT IN子句将执行一
个内部的排序和合并. 无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执
行了一个全表遍历). 为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或
NOT EXISTS。 
例子： 
（高效）SELECT * FROM  EMP (基础表)  WHERE  EMPNO > 0  AND  EXISTS (SELECT ‘X' 
FROM DEPT  WHERE  DEPT.DEPTNO = EMP.DEPTNO  AND  LOC = ‘MELB') 
(低效)SELECT  * FROM  EMP (基础表)  WHERE  EMPNO > 0  AND  DEPTNO IN(SELECT
DEPTNO  FROM  DEPT  WHERE  LOC = ‘MELB')

（16）识别'低效执行'的SQL语句：

虽然目前各种关于SQL优化的图形化工具层出不穷,但是写出自己的SQL工具来解决问题始终
是一个最好的方法： 
SELECT  EXECUTIONS , DISK_READS, BUFFER_GETS, 
ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) Hit_radio, 
ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run, 
SQL_TEXT 
FROM  V$SQLAREA 
WHERE  EXECUTIONS>0 
AND  BUFFER_GETS > 0 
AND  (BUFFER_GETS-DISK_READS)/BUFFER_GETS < 0.8 
ORDER BY  4 DESC;

（17）用索引提高效率：

索引是表的一个概念部分,用来提高检索数据的效率，ORACLE使用了一个复杂的自平衡
B-tree结构. 通常,通过索引查询数据比全表扫描要快. 当ORACLE找出执行查询和Update语
句的最佳路径时, ORACLE优化器将使用索引. 同样在联结多个表时使用索引也可以提高效
率. 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证.。那些LONG或
LONG RAW数据类型, 你可以索引几乎所有的列. 通常, 在大型表中使用索引特别有效. 当
然,你也会发现, 在扫描小表时,使用索引同样能提高效率. 虽然使用索引能得到查询效率
的提高,但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有
记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的INSERT ,
DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O . 因为索引需要额外的存储空间和处
理,那些不必要的索引反而会使查询反应时间变慢.。定期的重构索引是有必要的： 
ALTER  INDEX <INDEXNAME> REBUILD <TABLESPACENAME>

（18）用EXISTS替换DISTINCT：

当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用
DISTINCT. 一般可以考虑用EXIST替换, EXISTS 使查询更为迅速,因为RDBMS核心模块将在
子查询的条件一旦满足后,立刻返回结果. 例子： 
(低效): 
SELECT  DISTINCT  DEPT_NO,DEPT_NAME  FROM  DEPT D , EMP E WHERE  D.DEPT_NO =
E.DEPT_NO 
(高效): 
SELECT  DEPT_NO,DEPT_NAME  FROM  DEPT D  WHERE  EXISTS ( SELECT ‘X'  FROM  EMP
E  WHERE E.DEPT_NO = D.DEPT_NO);

（19） sql语句用大写的；因为oracle总是先解析sql语句，把小写的字母转换成大写的再
执行。

（20）在java代码中尽量少用连接符“＋”连接字符串！

（21）避免在索引列上使用NOT，通常我们要避免在索引列上使用NOT, NOT会产生在和在索
引列上使用函数相同的影响. 当ORACLE”遇到”NOT,他就会停止使用索引转而执行全表扫描
。

（22）避免在索引列上使用计算 
WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描．举例: 
低效： 
SELECT … FROM  DEPT  WHERE SAL * 12 > 25000; 
高效: 
SELECT … FROM DEPT WHERE SAL > 25000/12;

（23）用>=替代> 
高效: 
SELECT * FROM  EMP  WHERE  DEPTNO >=4 
低效: 
SELECT * FROM EMP WHERE DEPTNO >3 
两者的区别在于, 前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO
=3的记录并且向前扫描到第一个DEPT大于3的记录。

（24）用UNION替换OR (适用于索引列)

通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成
全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率
可能会因为你没有选择OR而降低. 在下面的例子中, LOC_ID 和REGION上都建有索引. 
高效: 
SELECT LOC_ID , LOC_DESC , REGION 
FROM LOCATION 
WHERE LOC_ID = 10 
UNION 
SELECT LOC_ID , LOC_DESC , REGION 
FROM LOCATION 
WHERE REGION = “MELBOURNE” 
低效: 
SELECT LOC_ID , LOC_DESC , REGION 
FROM LOCATION 
WHERE LOC_ID = 10 OR REGION = “MELBOURNE” 
如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面.

（25）用IN来替换OR

这是一条简单易记的规则，但是实际的执行效果还须检验，在ORACLE8i下，两者的执行路
径似乎是相同的． 
低效: 
SELECT…. FROM LOCATION WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30 
高效 
SELECT… FROM LOCATION WHERE LOC_IN  IN (10,20,30);

（26）避免在索引列上使用IS NULL和IS NOT NULL

避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引．对于单列索引，如果列
包含空值，索引中将不存在此记录. 对于复合索引，如果每个列都为空，索引中同样不存
在此记录. 如果至少有一个列不为空，则记录存在于索引中．举例: 如果唯一性索引建立
在表的A列和B列上, 并且表中存在一条记录的A,B值为(123,null) , ORACLE将不接受下一
条具有相同A,B值（123,null）的记录(插入). 然而如果所有的索引列都为空，ORACLE将认
为整个键值为空而空不等于空. 因此你可以插入1000 条具有相同键值的记录,当然它们都
是空! 因为空值不存在于索引列中,所以WHERE子句中对索引列进行空值比较将使ORACLE停
用该索引. 
低效: (索引失效) 
SELECT … FROM  DEPARTMENT  WHERE  DEPT_CODE IS NOT NULL; 
高效: (索引有效) 
SELECT … FROM  DEPARTMENT  WHERE  DEPT_CODE >=0;

（27）总是使用索引的第一个列：

如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,
优化器才会选择使用该索引. 这也是一条简单而重要的规则，当仅引用索引的第二个列时,
优化器使用了全表扫描而忽略了索引。

（28）用UNION-ALL 替换UNION ( 如果有可能的话)：

当SQL 语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并,
然后在输出最终结果前进行排序. 如果用UNION ALL替代UNION, 这样排序就不是必要了.
效率就会因此得到提高. 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录.
因此各位还是要从业务需求分析使用UNION ALL的可行性. UNION 将对结果集合排序,这个
操作会使用到SORT_AREA_SIZE这块内存. 对于这块内存的优化也是相当重要的. 下面的SQL
可以用来查询排序的消耗量 
低效： 
SELECT  ACCT_NUM, BALANCE_AMT 
FROM  DEBIT_TRANSACTIONS 
WHERE TRAN_DATE = '31-DEC-95' 
UNION 
SELECT ACCT_NUM, BALANCE_AMT 
FROM DEBIT_TRANSACTIONS 
WHERE TRAN_DATE = '31-DEC-95' 
高效: 
SELECT ACCT_NUM, BALANCE_AMT 
FROM DEBIT_TRANSACTIONS 
WHERE TRAN_DATE = '31-DEC-95' 
UNION ALL 
SELECT ACCT_NUM, BALANCE_AMT 
FROM DEBIT_TRANSACTIONS 
WHERE TRAN_DATE = '31-DEC-95'

（29）用WHERE替代ORDER BY：

ORDER BY 子句只在两种严格的条件下使用索引. 
ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序. 
ORDER BY中所有的列必须定义为非空. 
WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列. 
例如: 
表DEPT包含以下列: 
DEPT_CODE PK NOT NULL 
DEPT_DESC NOT NULL 
DEPT_TYPE NULL 
低效: (索引不被使用) 
SELECT DEPT_CODE FROM  DEPT  ORDER BY  DEPT_TYPE 
高效: (使用索引) 
SELECT DEPT_CODE  FROM  DEPT  WHERE  DEPT_TYPE > 0

（30）避免改变索引列的类型:

当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换. 
假设 EMPNO是一个数值类型的索引列. 
SELECT …  FROM EMP  WHERE  EMPNO = ‘123' 
实际上,经过ORACLE类型转换, 语句转化为: 
SELECT …  FROM EMP  WHERE  EMPNO = TO_NUMBER(‘123') 
幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变. 
现在,假设EMP_TYPE是一个字符类型的索引列. 
SELECT …  FROM EMP  WHERE EMP_TYPE = 123 
这个语句被ORACLE转换为: 
SELECT …  FROM EMP  WHERE TO_NUMBER(EMP_TYPE)=123 
因为内部发生的类型转换, 这个索引将不会被用到! 为了避免ORACLE对你的SQL进行隐式的
类型转换, 最好把类型转换用显式表现出来. 注意当字符和数值比较时, ORACLE会优先转
换数值类型到字符类型。

分析select   emp_name   form   employee   where   salary   >   3000   在此语句
中若salary是Float类型的，则优化器对其进行优化为Convert(float,3000)，因为3000是
个整数，我们应在编程时使用3000.0而不要等运行时让DBMS进行转化。同样字符和整型数
据的转换。


（31）需要当心的WHERE子句:

某些SELECT 语句中的WHERE子句不使用索引. 这里有一些例子. 
在下面的例子里, (1)‘!=' 将不使用索引. 记住, 索引只能告诉你什么存在于表中, 而不
能告诉你什么不存在于表中. (2) ‘ ¦ ¦'是字符连接函数. 就象其他函数那样, 停用了索
引. (3) ‘+'是数学函数. 就象其他数学函数那样, 停用了索引. (4)相同的索引列不能互
相比较,这将会启用全表扫描.

（32） a. 如果检索数据量超过30%的表中记录数.使用索引将没有显著的效率提高. b. 在
特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别. 而通常情况
下,使用索引比全表扫描要块几倍乃至几千倍!

（33）避免使用耗费资源的操作：

带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎执行耗费资源的
排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序. 通常,
带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写. 如果你的数据库的
SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的
可读性很强。

（34）优化GROUP BY：

提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查
询返回相同结果但第二个明显就快了许多. 
低效: 
SELECT JOB , AVG(SAL) 
FROM EMP 
GROUP by JOB 
HAVING JOB = ‘PRESIDENT' 
OR JOB = ‘MANAGER' 
高效: 
SELECT JOB , AVG(SAL) 
FROM EMP 
WHERE JOB = ‘PRESIDENT' 
OR JOB = ‘MANAGER' 
GROUP by JOB


转自：http://my.oschina.net/xianggao/blog/87216

另有参考 http://my.oschina.net/xianggao/blog/87448 数据库性能优化之SQL语句优化2

http://my.oschina.net/xianggao/blog/87450 数据库性能优化之SQL语句优化3

http://my.oschina.net/xianggao/blog/87453 数据库性能优化之SQL语句优化4

http://my.oschina.net/xianggao/blog/87223  关于如何形成一个好的数据库设计

SQL性能优化二

优化目标

 1. 减少 IO 次数
    IO永远是数据库最容易瓶颈的地方，这是由数据库的职责所决定的，大部分数据库操
    作中超过90%的时间都是 IO 操作所占用的，减少 IO 次数是 SQL 优化中需要第一优
    先考虑，当然，也是收效最明显的优化手段。
 2. 降低 CPU 计算
    除了 IO 瓶颈之外，SQL优化中需要考虑的就是 CPU 运算量的优化了。order by,
    group by,distinct … 都是消耗 CPU 的大户（这些操作基本上都是 CPU 处理内存中
    的数据比较运算）。当我们的 IO 优化做到一定阶段之后，降低 CPU 计算也就成为了
    我们 SQL 优化的重要目标

优化方法

 1. 改变 SQL 执行计划
    明确了优化目标之后，我们需要确定达到我们目标的方法。对于 SQL 语句来说，达到
    上述2个目标的方法其实只有一个，那就是改变 SQL 的执行计划，让他尽量“少走弯路
    ”，尽量通过各种“捷径”来找到我们需要的数据，以达到 “减少 IO 次数” 和 “降低
    CPU 计算” 的目标

常见误区

 1. count(1)和count(primary_key) 优于 count(*)
    很多人为了统计记录条数，就使用 count(1) 和 count(primary_key) 而不是 count
    (*) ，他们认为这样性能更好，其实这是一个误区。对于有些场景，这样做可能性能
    会更差，应为数据库对 count(*) 计数操作做了一些特别的优化。
 2. count(column) 和 count(*) 是一样的
    这个误区甚至在很多的资深工程师或者是 DBA 中都普遍存在，很多人都会认为这是理
    所当然的。实际上，count(column) 和 count(*) 是一个完全不一样的操作，所代表
    的意义也完全不一样。
    count(column) 是表示结果集中有多少个column字段不为空的记录
    count(*) 是表示整个结果集有多少条记录
 3. select a,b from … 比 select a,b,c from … 可以让数据库访问更少的数据量
    这个误区主要存在于大量的开发人员中，主要原因是对数据库的存储原理不是太了解
    。
    实际上，大多数关系型数据库都是按照行（row）的方式存储，而数据存取操作都是以
    一个固定大小的IO单元（被称作 block 或者 page）为单位，一般为4KB，8KB… 大多
    数时候，每个IO单元中存储了多行，每行都是存储了该行的所有字段（lob等特殊类型
    字段除外）。
    所以，我们是取一个字段还是多个字段，实际上数据库在表中需要访问的数据量其实
    是一样的。
    当然，也有例外情况，那就是我们的这个查询在索引中就可以完成，也就是说当只取
    a,b两个字段的时候，不需要回表，而c这个字段不在使用的索引中，需要回表取得其
    数据。在这样的情况下，二者的IO量会有较大差异。
 4. order by 一定需要排序操作
    我们知道索引数据实际上是有序的，如果我们的需要的数据和某个索引的顺序一致，
    而且我们的查询又通过这个索引来执行，那么数据库一般会省略排序操作，而直接将
    数据返回，因为数据库知道数据已经满足我们的排序需求了。
    实际上，利用索引来优化有排序需求的 SQL，是一个非常重要的优化手段
    延伸阅读：MySQL ORDER BY 的实现分析 ，MySQL 中 GROUP BY 基本实现原理 以及 
    MySQL DISTINCT 的基本实现原理 这3篇文章中有更为深入的分析，尤其是第一篇
 5. 执行计划中有 filesort 就会进行磁盘文件排序
    有这个误区其实并不能怪我们，而是因为 MySQL 开发者在用词方面的问题。filesort
    是我们在使用 explain 命令查看一条 SQL 的执行计划的时候可能会看到在 “Extra”
    一列显示的信息。
    实际上，只要一条 SQL 语句需要进行排序操作，都会显示“Using filesort”，这并不
    表示就会有文件排序操作。
    延伸阅读：理解 MySQL Explain 命令输出中的filesort，我在这里有更为详细的介绍

基本原则

 1. 尽量少 join
    MySQL 的优势在于简单，但这在某些方面其实也是其劣势。MySQL 优化器效率高，但
    是由于其统计信息的量有限，优化器工作过程出现偏差的可能性也就更多。对于复杂
    的多表 Join，一方面由于其优化器受限，再者在 Join 这方面所下的功夫还不够，所
    以性能表现离 Oracle 等关系型数据库前辈还是有一定距离。但如果是简单的单表查
    询，这一差距就会极小甚至在有些场景下要优于这些数据库前辈。
 2. 尽量少排序
    排序操作会消耗较多的 CPU 资源，所以减少排序可以在缓存命中率高等 IO 能力足够
    的场景下会较大影响 SQL 的响应时间。
    对于MySQL来说，减少排序有多种办法，比如：

      □ 上面误区中提到的通过利用索引来排序的方式进行优化
      □ 减少参与排序的记录条数
      □ 非必要不对数据进行排序
      □ …
 3. 尽量避免 select *
    很多人看到这一点后觉得比较难理解，上面不是在误区中刚刚说 select 子句中字段
    的多少并不会影响到读取的数据吗？
    是的，大多数时候并不会影响到 IO 量，但是当我们还存在 order by 操作的时候，
    select 子句中的字段多少会在很大程度上影响到我们的排序效率，这一点可以通过我
    之前一篇介绍 MySQL ORDER BY 的实现分析 的文章中有较为详细的介绍。
    此外，上面误区中不是也说了，只是大多数时候是不会影响到 IO 量，当我们的查询
    结果仅仅只需要在索引中就能找到的时候，还是会极大减少 IO 量的。
 4. 尽量用 join 代替子查询
    虽然 Join 性能并不佳，但是和 MySQL 的子查询比起来还是有非常大的性能优势。
    MySQL 的子查询执行计划一直存在较大的问题，虽然这个问题已经存在多年，但是到
    目前已经发布的所有稳定版本中都普遍存在，一直没有太大改善。虽然官方也在很早
    就承认这一问题，并且承诺尽快解决，但是至少到目前为止我们还没有看到哪一个版
    本较好的解决了这一问题。
 5. 尽量少 or
    当 where 子句中存在多个条件以“或”并存的时候，MySQL 的优化器并没有很好的解决
    其执行计划优化问题，再加上 MySQL 特有的 SQL 与 Storage 分层架构方式，造成了
    其性能比较低下，很多时候使用 union all 或者是union（必要的时候）的方式来代
    替“or”会得到更好的效果。
 6. 尽量用 union all 代替 union
    union 和 union all 的差异主要是前者需要将两个（或者多个）结果集合并后再进行
    唯一性过滤操作，这就会涉及到排序，增加大量的 CPU 运算，加大资源消耗及延迟。
    所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用
    union all 而不是 union。
 7. 尽量早过滤
    这一优化策略其实最常见于索引的优化设计中（将过滤性更好的字段放得更靠前）。
    在 SQL 编写中同样可以使用这一原则来优化一些 Join 的 SQL。比如我们在多个表进
    行分页数据查询的时候，我们最好是能够在一个表上先过滤好数据分好页，然后再用
    分好页的结果集与另外的表 Join，这样可以尽可能多的减少不必要的 IO 操作，大大
    节省 IO 操作所消耗的时间。
 8. 避免类型转换
    这里所说的“类型转换”是指 where 子句中出现 column 字段的类型和传入的参数类型
    不一致的时候发生的类型转换：

      □ 人为在column_name 上通过转换函数进行转换
        直接导致 MySQL（实际上其他数据库也会有同样的问题）无法使用索引，如果非
        要转换，应该在传入的参数上进行转换
      □ 由数据库自己进行转换
        如果我们传入的数据类型和字段类型不一致，同时我们又没有做任何类型转换处
        理，MySQL 可能会自己对我们的数据进行类型转换操作，也可能不进行处理而交
        由存储引擎去处理，这样一来，就会出现索引无法使用的情况而造成执行计划问
        题。
 9. 优先优化高并发的 SQL，而不是执行频率低某些“大”SQL
    对于破坏性来说，高并发的 SQL 总是会比低频率的来得大，因为高并发的 SQL 一旦
    出现问题，甚至不会给我们任何喘息的机会就会将系统压跨。而对于一些虽然需要消
    耗大量 IO 而且响应很慢的 SQL，由于频率低，即使遇到，最多就是让整个系统响应
    慢一点，但至少可能撑一会儿，让我们有缓冲的机会。
10. 从全局出发优化，而不是片面调整
    SQL 优化不能是单独针对某一个进行，而应充分考虑系统中所有的 SQL，尤其是在通
    过调整索引优化 SQL 的执行计划的时候，千万不能顾此失彼，因小失大。
11. 尽可能对每一条运行在数据库中的SQL进行 explain
    优化 SQL，需要做到心中有数，知道 SQL 的执行计划才能判断是否有优化余地，才能
    判断是否存在执行计划问题。在对数据库中运行的 SQL 进行了一段时间的优化之后，
    很明显的问题 SQL 可能已经很少了，大多都需要去发掘，这时候就需要进行大量的
    explain 操作收集执行计划，并判断是否需要进行优化




Mysql性能优化之引擎的选择


MySQL 的存储引擎可能是所有关系型数据库产品中最具有特色的了，不仅可以同时使用多
种存储引擎，而且每种存储引擎和MySQL之间使用插件方式这种非常松的耦合关系。

由于各存储引擎功能特性差异较大，这篇文章主要是介绍如何来选择合适的存储引擎来应
对不同的业务场景。

  • MyISAM
      □ 特性
         1. 不支持事务：MyISAM存储引擎不支持事务，所以对事务有要求的业务场景不
            能使用
         2. 表级锁定：其锁定机制是表级索引，这虽然可以让锁定的实现成本很小但是
            也同时大大降低了其并发性能
         3. 读写互相阻塞：不仅会在写入的时候阻塞读取，MyISAM还会在读取的时候阻
            塞写入，但读本身并不会阻塞另外的读
         4. 只会缓存索引：MyISAM可以通过key_buffer缓存以大大提高访问性能减少磁
            盘IO，但是这个缓存区只会缓存索引，而不会缓存数据
      □ 适用场景
         1. 不需要事务支持（不支持）
         2. 并发相对较低（锁定机制问题）
         3. 数据修改相对较少（阻塞问题）
         4. 以读为主
         5. 数据一致性要求不是非常高
      □ 最佳实践
         1. 尽量索引（缓存机制）
         2. 调整读写优先级，根据实际需求确保重要操作更优先
         3. 启用延迟插入改善大批量写入性能
         4. 尽量顺序操作让insert数据都写入到尾部，减少阻塞
         5. 分解大的操作，降低单个操作的阻塞时间
         6. 降低并发数，某些高并发场景通过应用来进行排队机制
         7. 对于相对静态的数据，充分利用Query Cache可以极大的提高访问效率
         8. MyISAM的Count只有在全表扫描的时候特别高效，带有其他条件的count都需
            要进行实际的数据访问
  • InnoDB
      □ 特性
         1. 具有较好的事务支持：支持4个事务隔离级别，支持多版本读
         2. 行级锁定：通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响
         3. 读写阻塞与事务隔离级别相关
         4. 具有非常高效的缓存特性：能缓存索引，也能缓存数据
         5. 整个表和主键以Cluster方式存储，组成一颗平衡树
         6. 所有Secondary Index都会保存主键信息
      □ 适用场景
         1. 需要事务支持（具有较好的事务特性）
         2. 行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成
         3. 数据更新较为频繁的场景
         4. 数据一致性要求较高
         5. 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，尽
            可能减少磁盘 IO
      □ 最佳实践
         1. 主键尽可能小，避免给Secondary index带来过大的空间负担
         2. 避免全表扫描，因为会使用表锁
         3. 尽可能缓存所有的索引和数据，提高响应速度
         4. 在大批量小插入的时候，尽量自己控制事务而不要使用autocommit自动提交
         5. 合理设置innodb_flush_log_at_trx_commit参数值，不要过度追求安全性
         6. 避免主键更新，因为这会带来大量的数据移动
  • NDBCluster
      □ 特性
         1. 分布式：分布式存储引擎，可以由多个NDBCluster存储引擎组成集群分别存
            放整体数据的一部分
         2. 支持事务：和Innodb一样，支持事务
         3. 可与mysqld不在一台主机：可以和mysqld分开存在于独立的主机上，然后通
            过网络和mysqld通信交互
         4. 内存需求量巨大：新版本索引以及被索引的数据必须存放在内存中，老版本
            所有数据和索引必须存在与内存中
      □ 适用场景
         1. 具有非常高的并发需求
         2. 对单个请求的响应并不是非常的critical
         3. 查询简单，过滤条件较为固定，每次请求数据量较少，又不希望自己进行水
            平Sharding
      □ 最佳实践
         1. 尽可能让查询简单，避免数据的跨节点传输
         2. 尽可能满足SQL节点的计算性能，大一点的集群SQL节点会明显多余Data节点
         3. 在各节点之间尽可能使用万兆网络环境互联，以减少数据在网络层传输过程
            中的延时



Mysql性能优化 --- 包含SQL、表结构、索引和缓存


  • 优化目标
     1. 减少 IO 次数
        IO永远是数据库最容易瓶颈的地方，这是由数据库的职责所决定的，大部分数据
        库操作中超过90%的时间都是 IO 操作所占用的，减少 IO 次数是 SQL 优化中需
        要第一优先考虑，当然，也是收效最明显的优化手段。
     2. 降低 CPU 计算
        除了 IO 瓶颈之外，SQL优化中需要考虑的就是 CPU 运算量的优化了。order by,
        group by,distinct … 都是消耗 CPU 的大户（这些操作基本上都是 CPU 处理内
        存中的数据比较运算）。当我们的 IO 优化做到一定阶段之后，降低 CPU 计算也
        就成为了我们 SQL 优化的重要目标
  • 优化方法
     1. 改变 SQL 执行计划
        明确了优化目标之后，我们需要确定达到我们目标的方法。对于 SQL 语句来说，
        达到上述2个目标的方法其实只有一个，那就是改变 SQL 的执行计划，让他尽量“
        少走弯路”，尽量通过各种“捷径”来找到我们需要的数据，以达到 “减少 IO 次数
        ” 和 “降低 CPU 计算” 的目标
  • 常见误区
     1. count(1)和count(primary_key) 优于 count(*)
        很多人为了统计记录条数，就使用 count(1) 和 count(primary_key) 而不是
        count(*) ，他们认为这样性能更好，其实这是一个误区。对于有些场景，这样做
        可能性能会更差，应为数据库对 count(*) 计数操作做了一些特别的优化。
     2. count(column) 和 count(*) 是一样的
        这个误区甚至在很多的资深工程师或者是 DBA 中都普遍存在，很多人都会认为这
        是理所当然的。实际上，count(column) 和 count(*) 是一个完全不一样的操作
        ，所代表的意义也完全不一样。
        count(column) 是表示结果集中有多少个column字段不为空的记录
        count(*) 是表示整个结果集有多少条记录
     3. select a,b from … 比 select a,b,c from … 可以让数据库访问更少的数据量
        这个误区主要存在于大量的开发人员中，主要原因是对数据库的存储原理不是太
        了解。
        实际上，大多数关系型数据库都是按照行（row）的方式存储，而数据存取操作都
        是以一个固定大小的IO单元（被称作 block 或者 page）为单位，一般为4KB，
        8KB… 大多数时候，每个IO单元中存储了多行，每行都是存储了该行的所有字段（
        lob等特殊类型字段除外）。
        所以，我们是取一个字段还是多个字段，实际上数据库在表中需要访问的数据量
        其实是一样的。
        当然，也有例外情况，那就是我们的这个查询在索引中就可以完成，也就是说当
        只取 a,b两个字段的时候，不需要回表，而c这个字段不在使用的索引中，需要回
        表取得其数据。在这样的情况下，二者的IO量会有较大差异。
     4. order by 一定需要排序操作
        我们知道索引数据实际上是有序的，如果我们的需要的数据和某个索引的顺序一
        致，而且我们的查询又通过这个索引来执行，那么数据库一般会省略排序操作，
        而直接将数据返回，因为数据库知道数据已经满足我们的排序需求了。
        实际上，利用索引来优化有排序需求的 SQL，是一个非常重要的优化手段
        延伸阅读：MySQL ORDER BY 的实现分析 ，MySQL 中 GROUP BY 基本实现原理 以
        及 MySQL DISTINCT 的基本实现原理 这3篇文章中有更为深入的分析，尤其是第
        一篇
     5. 执行计划中有 filesort 就会进行磁盘文件排序
        有这个误区其实并不能怪我们，而是因为 MySQL 开发者在用词方面的问题。
        filesort 是我们在使用 explain 命令查看一条 SQL 的执行计划的时候可能会看
        到在 “Extra” 一列显示的信息。
        实际上，只要一条 SQL 语句需要进行排序操作，都会显示“Using filesort”，这
        并不表示就会有文件排序操作。
        延伸阅读：理解 MySQL Explain 命令输出中的filesort，我在这里有更为详细的
        介绍
  • 基本原则
     1. 尽量少 join
        MySQL 的优势在于简单，但这在某些方面其实也是其劣势。MySQL 优化器效率高
        ，但是由于其统计信息的量有限，优化器工作过程出现偏差的可能性也就更多。
        对于复杂的多表 Join，一方面由于其优化器受限，再者在 Join 这方面所下的功
        夫还不够，所以性能表现离 Oracle 等关系型数据库前辈还是有一定距离。但如
        果是简单的单表查询，这一差距就会极小甚至在有些场景下要优于这些数据库前
        辈。
     2. 尽量少排序
        排序操作会消耗较多的 CPU 资源，所以减少排序可以在缓存命中率高等 IO 能力
        足够的场景下会较大影响 SQL 的响应时间。
        对于MySQL来说，减少排序有多种办法，比如：
          ☆ 上面误区中提到的通过利用索引来排序的方式进行优化
          ☆ 减少参与排序的记录条数
          ☆ 非必要不对数据进行排序
          ☆ 避免使用耗费资源的操作，带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY
            的SQL语句会启动SQL引擎执行，耗费资源的排序(SORT)功能. DISTINCT需要
            一次排序操作, 而其他的至少需要执行两次排序
          ☆ …
     3. 尽量避免 select *
        很多人看到这一点后觉得比较难理解，上面不是在误区中刚刚说 select 子句中
        字段的多少并不会影响到读取的数据吗？
        是的，大多数时候并不会影响到 IO 量，但是当我们还存在 order by 操作的时
        候，select 子句中的字段多少会在很大程度上影响到我们的排序效率，这一点可
        以通过我之前一篇介绍 MySQL ORDER BY 的实现分析 的文章中有较为详细的介绍
        。
        此外，上面误区中不是也说了，只是大多数时候是不会影响到 IO 量，当我们的
        查询结果仅仅只需要在索引中就能找到的时候，还是会极大减少 IO 量的。
     4. 尽量用 join 代替子查询
        虽然 Join 性能并不佳，但是和 MySQL 的子查询比起来还是有非常大的性能优势
        。MySQL 的子查询执行计划一直存在较大的问题，虽然这个问题已经存在多年，
        但是到目前已经发布的所有稳定版本中都普遍存在，一直没有太大改善。虽然官
        方也在很早就承认这一问题，并且承诺尽快解决，但是至少到目前为止我们还没
        有看到哪一个版本较好的解决了这一问题。
     5. 尽量少 or
        当 where 子句中存在多个条件以“或”并存的时候，MySQL 的优化器并没有很好的
        解决其执行计划优化问题，再加上 MySQL 特有的 SQL 与 Storage 分层架构方式
        ，造成了其性能比较低下，很多时候使用 union all 或者是union（必要的时候
        ）的方式来代替“or”会得到更好的效果。
     6. 尽量用 union all 代替 union
        union 和 union all 的差异主要是前者需要将两个（或者多个）结果集合并后再
        进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU 运算，加大资源消耗
        及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时
        候，尽量使用 union all 而不是 union。
     7. 尽量早过滤
        这一优化策略其实最常见于索引的优化设计中（将过滤性更好的字段放得更靠前
        ）。
        在 SQL 编写中同样可以使用这一原则来优化一些 Join 的 SQL。比如我们在多个
        表进行分页数据查询的时候，我们最好是能够在一个表上先过滤好数据分好页，
        然后再用分好页的结果集与另外的表 Join，这样可以尽可能多的减少不必要的
        IO 操作，大大节省 IO 操作所消耗的时间。
     8. 避免类型转换
        这里所说的“类型转换”是指 where 子句中出现 column 字段的类型和传入的参数
        类型不一致的时候发生的类型转换：
          ☆ 人为在column_name 上通过转换函数进行转换
            直接导致 MySQL（实际上其他数据库也会有同样的问题）无法使用索引，如
            果非要转换，应该在传入的参数上进行转换
          ☆ ┌────────────────────────────────────────────────────────────────────┐
            │SELECT emp.ename, emp.job FROM emp WHERE emp.empno = 7369;          │
            │不要使用：SELECT emp.ename, emp.job FROM emp WHERE emp.empno = ‘7369│
            └────────────────────────────────────────────────────────────────────┘
          ☆ 由数据库自己进行转换
            如果我们传入的数据类型和字段类型不一致，同时我们又没有做任何类型转
            换处理，MySQL 可能会自己对我们的数据进行类型转换操作，也可能不进行
            处理而交由存储引擎去处理，这样一来，就会出现索引无法使用的情况而造
            成执行计划问题。
     9. 优先优化高并发的 SQL，而不是执行频率低某些“大”SQL
        对于破坏性来说，高并发的 SQL 总是会比低频率的来得大，因为高并发的 SQL
        一旦出现问题，甚至不会给我们任何喘息的机会就会将系统压跨。而对于一些虽
        然需要消耗大量 IO 而且响应很慢的 SQL，由于频率低，即使遇到，最多就是让
        整个系统响应慢一点，但至少可能撑一会儿，让我们有缓冲的机会。
    10. 从全局出发优化，而不是片面调整
        SQL 优化不能是单独针对某一个进行，而应充分考虑系统中所有的 SQL，尤其是
        在通过调整索引优化 SQL 的执行计划的时候，千万不能顾此失彼，因小失大。
    11. 尽可能对每一条运行在数据库中的SQL进行 explain
        优化 SQL，需要做到心中有数，知道 SQL 的执行计划才能判断是否有优化余地，
        才能判断是否存在执行计划问题。在对数据库中运行的 SQL 进行了一段时间的优
        化之后，很明显的问题 SQL 可能已经很少了，大多都需要去发掘，这时候就需要
        进行大量的 explain 操作收集执行计划，并判断是否需要进行优化。


二、MySQL 数据库性能优化之表结构

很多人都将 数据库设计范式 作为数据库表结构设计“圣经”，认为只要按照这个范式需求
设计，就能让设计出来的表结构足够优化，既能保证性能优异同时还能满足扩展性要求。
殊不知，在N年前被奉为“圣经”的数据库设计3范式早就已经不完全适用了。这里我整理了
一些比较常见的数据库表结构设计方面的优化技巧，希望对大家有用。由于MySQL数据库是
基于行（Row）存储的数据库，而数据库操作 IO 的时候是以 page（block）的方式，也就
是说，如果我们每条记录所占用的空间量减小，就会使每个page中可存放的数据行数增大
，那么每次 IO 可访问的行数也就增多了。反过来说，处理相同行数的数据，需要访问的
page 就会减少，也就是 IO 操作次数降低，直接提升性能。此外，由于我们的内存是有限
的，增加每个page中存放的数据行数，就等于增加每个内存块的缓存数据量，同时还会提
升内存换中数据命中的几率，也就是缓存命中率。

  • 数据类型选择
    数据库操作中最为耗时的操作就是 IO 处理，大部分数据库操作 90% 以上的时间都花
    在了 IO 读写上面。所以尽可能减少 IO 读写量，可以在很大程度上提高数据库操作
    的性能。我们无法改变数据库中需要存储的数据，但是我们可以在这些数据的存储方
    式方面花一些心思。下面的这些关于字段类型的优化建议主要适用于记录条数较多，
    数据量较大的场景，因为精细化的数据类型设置可能带来维护成本的提高，过度优化
    也可能会带来其他的问题：
     1. 数字类型：非万不得已不要使用DOUBLE，不仅仅只是存储长度的问题，同时还会
        存在精确性的问题。同样，固定精度的小数，也不建议使用DECIMAL，建议乘以固
        定倍数转换成整数存储，可以大大节省存储空间，且不会带来任何附加维护成本
        。对于整数的存储，在数据量较大的情况下，建议区分开 TINYINT / INT /
        BIGINT 的选择，因为三者所占用的存储空间也有很大的差别，能确定不会使用负
        数的字段，建议添加unsigned定义。当然，如果数据量较小的数据库，也可以不
        用严格区分三个整数类型。
     2. 字符类型：非万不得已不要使用 TEXT 数据类型，其处理方式决定了他的性能要
        低于char或者是varchar类型的处理。定长字段，建议使用 CHAR 类型，不定长字
        段尽量使用 VARCHAR，且仅仅设定适当的最大长度，而不是非常随意的给一个很
        大的最大长度限定，因为不同的长度范围，MySQL也会有不一样的存储处理。
     3. 时间类型：尽量使用TIMESTAMP类型，因为其存储空间只需要 DATETIME 类型的一
        半。对于只需要精确到某一天的数据类型，建议使用DATE类型，因为他的存储空
        间只需要3个字节，比TIMESTAMP还少。不建议通过INT类型类存储一个unix
        timestamp 的值，因为这太不直观，会给维护带来不必要的麻烦，同时还不会带
        来任何好处。
     4. ENUM & SET：对于状态字段，可以尝试使用 ENUM 来存放，因为可以极大的降低
        存储空间，而且即使需要增加新的类型，只要增加于末尾，修改结构也不需要重
        建表数据。如果是存放可预先定义的属性数据呢？可以尝试使用SET类型，即使存
        在多种属性，同样可以游刃有余，同时还可以节省不小的存储空间。
     5. LOB类型：强烈反对在数据库中存放 LOB 类型数据，虽然数据库提供了这样的功
        能，但这不是他所擅长的，我们更应该让合适的工具做他擅长的事情，才能将其
        发挥到极致。在数据库中存储 LOB 数据就像让一个多年前在学校学过一点Java的
        营销专业人员来写 Java 代码一样。
  • 字符编码
    字符集直接决定了数据在MySQL中的存储编码方式，由于同样的内容使用不同字符集表
    示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽
    可能减少数据量，进而减少IO操作次数。
     1. 纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会
        节省大量的存储空间
     2. 如果我们可以确定不需要存放多种语言，就没必要非得使用UTF8或者其他UNICODE
        字符类型，这回造成大量的存储空间浪费
     3. MySQL的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据
        的时候，可以通过对不同表不同字段使用不同的数据类型来较大程度减小数据存
        储量，进而降低 IO 操作次数并提高缓存命中率
  • 适当拆分
    有些时候，我们可能会希望将一个完整的对象对应于一张数据库表，这对于应用程序
    开发来说是很有好的，但是有些时候可能会在性能上带来较大的问题。当我们的表中
    存在类似于 TEXT 或者是很大的 VARCHAR类型的大字段的时候，如果我们大部分访问
    这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，
    以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存
    储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中
    率。

上面几点的优化都是为了减少每条记录的存储空间大小，让每个数据库中能够存储更多的
记录条数，以达到减少 IO 操作次数，提高缓存命中率。下面这个优化建议可能很多开发
人员都会觉得不太理解，因为这是典型的反范式设计，而且也和上面的几点优化建议的目
标相违背。

  • 适度冗余
    为什么我们要冗余？这不是增加了每条数据的大小，减少了每个数据块可存放记录条
    数吗？确实，这样做是会增大每条记录的大小，降低每条记录中可存放数据的条数，
    但是在有些场景下我们仍然还是不得不这样做：
     1. 被频繁引用且只能通过 Join 2张（或者更多）大表的方式才能得到的独立小字段
        这样的场景由于每次Join仅仅只是为了取得某个小字段的值，Join到的记录又大
        ，会造成大量不必要的 IO，完全可以通过空间换取时间的方式来优化。不过，冗
        余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更
        新
  • 尽量使用 NOT NULL
    NULL 类型比较特殊，SQL 难优化。虽然 MySQL NULL类型和 Oracle 的NULL 有差异，
    会进入索引中，但如果是一个组合索引，那么这个NULL 类型的字段会极大影响整个索
    引的效率。此外，NULL 在索引中的处理也是特殊的，也会占用额外的存放空间。
    很多人觉得 NULL 会节省一些空间，所以尽量让NULL来达到节省IO的目的，但是大部
    分时候这会适得其反，虽然空间上可能确实有一定节省，倒是带来了很多其他的优化
    问题，不但没有将IO量省下来，反而加大了SQL的IO量。所以尽量确保 DEFAULT 值不
    是 NULL，也是一个很好的表结构设计优化习惯。

 三、MySQL 数据库性能优化之索引优化

大家都知道索引对于数据访问的性能有非常关键的作用，都知道索引可以提高数据访问效
率。为什么索引能提高数据访问性能？他会不会有“副作用”？是不是索引创建越多，性能
就越好？到底该如何设计索引，才能最大限度的发挥其效能？这篇文章主要是带着上面这
几个问题来做一个简要的分析，同时排除了业务场景所带来的特殊性，请不要纠结业务场
景的影响。

  • 索引为什么能提高数据访问性能？
    很多人只知道索引能够提高数据库的性能，但并不是特别了解其原理，其实我们可以
    用一个生活中的示例来理解。我们让一位不太懂计算机的朋友去图书馆确认一本叫做
    《MySQL性能调优与架构设计》的书是否在藏，这样对他说：“请帮我借一本计算机类
    的数据库书籍，是属于 MySQL 数据库范畴的，叫做《MySQL性能调优与架构设计》”。
    朋友会根据所属类别，前往存放“计算机”书籍区域的书架，然后再寻找“数据库”类存
    放位置，再找到一堆讲述“MySQL”的书籍，最后可能发现目标在藏（也可能已经借出不
    在书架上）。在这个过程中： “计算机”->“数据库”->“MySQL”->“在藏”->《MySQL性能
    调优与架构设计》其实就是一个“根据索引查找数据”的典型案例，“计算机”->“数据库
    ”->“MySQL”->“在藏” 就是朋友查找书籍的索引。假设没有这个索引，那查找这本书的
    过程会变成怎样呢？朋友只能从图书馆入口一个书架一个书架的“遍历”，直到找到《
    MySQL性能调优与架构设计》这本书为止。如果幸运，可能在第一个书架就找到。但如
    果不幸呢，那就惨了，可能要将整个图书馆所有的书架都找一遍才能找到我们想要的
    这本书。注：这个例子中的“索引”是记录在朋友大脑中的，实际上，每个图书馆都会
    有一个非常全的实际存在的索引系统（大多位于入口显眼处），由很多个贴上了明显
    标签的小抽屉构成。这个索引系统中存放这非常齐全详尽的索引数据，标识出我们需
    要查找的“目标”在某个区域的某个书架上。而且每当有新的书籍入库，旧的书籍销毁
    以及书记信息修改，都需要对索引系统进行及时的修正。

下面我们通过上面这个生活中的小示例，来分析一下索引，看看能的出哪些结论？

  • 索引有哪些“副作用”？
     1. 图书的变更（增，删，改）都需要修订索引，索引存在额外的维护成本
     2. 查找翻阅索引系统需要消耗时间，索引存在额外的访问成本
     3. 这个索引系统需要一个地方来存放，索引存在额外的空间成本
  • 索引是不是越多越好？
     1. 如果我们的这个图书馆只是一个进出中转站，里面的新书进来后很快就会转发去
        其他图书馆而从这个馆藏中“清除”，那我们的索引就只会不断的修改，而很少会
        被用来查找图书
        所以，对于类似于这样的存在非常大更新量的数据，索引的维护成本会非常高，
        如果其检索需求很少，而且对检索效率并没有非常高的要求的时候，我们并不建
        议创建索引，或者是尽量减少索引。
     2. 如果我们的书籍量少到只有几本或者就只有一个书架，索引并不会带来什么作用
        ，甚至可能还会浪费一些查找索引所花费的时间。
        所以，对于数据量极小到通过索引检索还不如直接遍历来得快的数据，也并不适
        合使用索引。
     3. 如果我们的图书馆只有一个10平方的面积，现在连放书架都已经非常拥挤，而且
        馆藏还在不断增加，我们还能考虑创建索引吗？
        所以，当我们连存储基础数据的空间都捉襟见肘的时候，我们也应该尽量减少低
        效或者是去除索引。
  • 索引该如何设计才高效？
     1. 如果我们仅仅只是这样告诉对方的：“帮我确认一本数据库类别的讲述 MySQL 的
        叫做《MySQL性能调优与架构设计》的书是否在藏”，结果又会如何呢？朋友只能
        一个大类区域一个大类区域的去寻找“数据库”类别，然后再找到 “MySQL”范畴，
        再看到我们所需是否在藏。由于我们少说了一个“计算机类”，朋友就必须到每一
        个大类去寻找。
        所以，我们应该尽量让查找条件尽可能多的在索引中，尽可能通过索引完成所有
        过滤，回表只是取出额外的数据字段。
     2. 如果我们是这样说的：“帮我确认一本讲述 MySQL 的数据库范畴的计算机丛书，
        叫做《MySQL性能调优与架构设计》，看是否在藏”。如果这位朋友并不知道计算
        机是一个大类，也不知道数据库属于计算机大类，那这位朋友就悲剧了。首先他
        得遍历每个类别确认“MySQL”存在于哪些类别中，然后从包含 “MySQL” 书籍中再
        看有哪些是“数据库”范畴的（有可能部分是讲述PHP或者其他开发语言的），然后
        再排除非计算机类的（虽然可能并没有必要），然后才能确认。
        所以，字段的顺序对组合索引效率有至关重要的作用，过滤效果越好的字段需要
        更靠前。
     3. 如果我们还有这样一个需求（虽然基本不可能）：“帮我将图书馆中所有的计算机
        图书借来”。朋友如果通过索引来找，每次都到索引柜找到计算机书籍所在的区域
        ，然后从书架上搬下一格（假设只能以一格为单位从书架上取下，类比数据库中
        以block/page为单位读取），取出第一本，然后再从索引柜找到计算机图书所在
        区域，再搬下一格，取出一本… 如此往复直至取完所有的书。如果他不通过索引
        来找又会怎样呢？他需要从地一个书架一直往后找，当找到计算机的书，搬下一
        格，取出所有计算机的书，再往后，直至所有书架全部看一遍。在这个过程中，
        如果计算机类书籍较多，通过索引来取所花费的时间很可能要大于直接遍历，因
        为不断往复的索引翻阅所消耗的时间会非常长。（延伸阅读：这里有一篇以前写
        的关于Oracle的文章，索引扫描还是全表扫描（Index Scan Or Full Table Scan
        ））
        所以，当我们需要读取的数据量占整个数据量的比例较大抑或者说索引的过滤效
        果并不是太好的时候，使用索引并不一定优于全表扫描。
     4. 如果我们的朋友不知道“数据库”这个类别可以属于“计算机”这个大类，抑或者图
        书馆的索引系统中这两个类别属性并没有关联关系，又会怎样呢？也就是说，朋
        友得到的是2个独立的索引，一个是告知“计算机”这个大类所在的区域，一个是“
        数据库”这个小类所在的区域（很可能是多个区域），那么他只能二者选其一来搜
        索我的需求。即使朋友可以分别通过2个索引检索然后自己在脑中取交集再找，那
        这样的效率实际过程中也会比较低下。
        所以，在实际使用过程中，一次数据访问一般只能利用到1个索引，这一点在索引
        创建过程中一定要注意，不是说一条SQL语句中Where子句里面每个条件都有索引
        能对应上就可以了。
     5. 最后总结一下法则：不要在建立的索引的数据列上进行下列操作:
        ◆避免对索引字段进行计算操作◆避免在索引字段上使用not，，!=◆避免在索引列
        上使用IS NULL和IS NOT NULL◆避免在索引列上出现数据类型转换◆避免在索引字
        段上使用函数◆避免建立索引的列中使用空值。

 四、MySQL 数据库性能优化之缓存参数优化

数据库属于 IO 密集型的应用程序，其主要职责就是数据的管理及存储工作。而我们知道
，从内存中读取一个数据库的时间是微秒级别，而从一块普通硬盘上读取一个IO是在毫秒
级别，二者相差3个数量级。所以，要优化数据库，首先第一步需要优化的就是 IO，尽可
能将磁盘IO转化为内存IO。本文先从 MySQL 数据库IO相关参数（缓存参数）的角度来看看
可以通过哪些参数进行IO优化：

  • query_cache_size/query_cache_type （global） Query cache 作用于整个 MySQL
    Instance，主要用来缓存 MySQL 中的 ResultSet，也就是一条SQL语句执行的结果集
    ，所以仅仅只能针对select语句。当我们打开了 Query Cache 功能，MySQL在接受到
    一条select语句的请求后，如果该语句满足Query Cache的要求（未显式说明不允许使
    用Query Cache，或者已经显式申明需要使用Query Cache），MySQL 会直接根据预先
    设定好的HASH算法将接受到的select语句以字符串方式进行hash，然后到Query Cache
    中直接查找是否已经缓存。也就是说，如果已经在缓存中，该select请求就会直接将
    数据返回，从而省略了后面所有的步骤（如 SQL语句的解析，优化器优化以及向存储
    引擎请求数据等），极大的提高性能。当然，Query Cache 也有一个致命的缺陷，那
    就是当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query
    Cache 中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query
    Cache 可能会得不偿失。Query Cache的使用需要多个参数配合，其中最为关键的是
    query_cache_size 和 query_cache_type ，前者设置用于缓存 ResultSet 的内存大
    小，后者设置在何场景下使用 Query Cache。在以往的经验来看，如果不是用来缓存
    基本不变的数据的MySQL数据库，query_cache_size 一般 256MB 是一个比较合适的大
    小。当然，这可以通过计算Query Cache的命中率（Qcache_hits/
    (Qcache_hits+Qcache_inserts)*100)）来进行调整。query_cache_type可以设置为0
    (OFF)，1(ON)或者2(DEMOND)，分别表示完全不使用query cache，除显式要求不使用
    query cache（使用sql_no_cache）之外的所有的select都使用query cache，只有显
    示要求才使用query cache（使用sql_cache）。
  • binlog_cache_size （global） Binlog Cache 用于在打开了二进制日志（binlog）
    记录功能的环境，是 MySQL 用来提高binlog的记录效率而设计的一个用于短时间内临
    时缓存binlog数据的内存区域。一般来说，如果我们的数据库中没有什么大事务，写
    入也不是特别频繁，2MB～4MB是一个合适的选择。但是如果我们的数据库大事务较多
    ，写入量比较大，可与适当调高binlog_cache_size。同时，我们可以通过
    binlog_cache_use 以及 binlog_cache_disk_use来分析设置的binlog_cache_size是
    否足够，是否有大量的binlog_cache由于内存大小不够而使用临时文件（
    binlog_cache_disk_use）来缓存了。
  • key_buffer_size （global） Key Buffer 可能是大家最为熟悉的一个 MySQL 缓存参
    数了，尤其是在 MySQL 没有更换默认存储引擎的时候，很多朋友可能会发现，默认的
    MySQL 配置文件中设置最大的一个内存参数就是这个参数了。key_buffer_size 参数
    用来设置用于缓存 MyISAM存储引擎中索引文件的内存区域大小。如果我们有足够的内
    存，这个缓存区域最好是能够存放下我们所有的 MyISAM 引擎表的所有索引，以尽可
    能提高性能。此外，当我们在使用MyISAM 存储的时候有一个及其重要的点需要注意，
    由于 MyISAM 引擎的特性限制了他仅仅只会缓存索引块到内存中，而不会缓存表数据
    库块。所以，我们的 SQL 一定要尽可能让过滤条件都在索引中，以便让缓存帮助我们
    提高查询效率。
  • bulk_insert_buffer_size （thread）和key_buffer_size一样，这个参数同样也仅作
    用于使用 MyISAM存储引擎，用来缓存批量插入数据的时候临时缓存写入数据。当我们
    使用如下几种数据写入语句的时候，会使用这个内存区域来缓存批量结构的数据以帮
    助批量写入数据文件：insert … select …
    insert … values (…) ,(…),(…)…
    load data infile… into… (非空表)
  • innodb_buffer_pool_size（global）当我们使用InnoDB存储引擎的时候，
    innodb_buffer_pool_size 参数可能是影响我们性能的最为关键的一个参数了，他用
    来设置用于缓存 InnoDB 索引及数据块的内存区域大小，类似于 MyISAM 存储引擎的
    key_buffer_size 参数，当然，可能更像是 Oracle 的 db_cache_size。简单来说，
    当我们操作一个 InnoDB 表的时候，返回的所有数据或者去数据过程中用到的任何一
    个索引块，都会在这个内存区域中走一遭。和key_buffer_size 对于 MyISAM 引擎一
    样，innodb_buffer_pool_size 设置了 InnoDB 存储引擎需求最大的一块内存区域的
    大小，直接关系到 InnoDB存储引擎的性能，所以如果我们有足够的内存，尽可将该参
    数设置到足够打，将尽可能多的 InnoDB 的索引及数据都放入到该缓存区域中，直至
    全部。我们可以通过 (Innodb_buffer_pool_read_requests –
    Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests * 100% 计算缓
    存命中率，并根据命中率来调整 innodb_buffer_pool_size 参数大小进行优化。
  • innodb_additional_mem_pool_size（global）这个参数我们平时调整的可能不是太多
    ，很多人都使用了默认值，可能很多人都不是太熟悉这个参数的作用。
    innodb_additional_mem_pool_size 设置了InnoDB存储引擎用来存放数据字典信息以
    及一些内部数据结构的内存空间大小，所以当我们一个MySQL Instance中的数据库对
    象非常多的时候，是需要适当调整该参数的大小以确保所有数据都能存放在内存中提
    高访问效率的。这个参数大小是否足够还是比较容易知道的，因为当过小的时候，
    MySQL 会记录 Warning 信息到数据库的 error log 中，这时候你就知道该调整这个
    参数大小了。
  • innodb_log_buffer_size （global）这是 InnoDB 存储引擎的事务日志所使用的缓冲
    区。类似于 Binlog Buffer，InnoDB 在写事务日志的时候，为了提高性能，也是先将
    信息写入 Innofb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设
    置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘
    ）中。可以通过 innodb_log_buffer_size 参数设置其可以使用的最大内存空间。
    注：innodb_flush_log_trx_commit 参数对 InnoDB Log 的写入性能有非常关键的影
    响。该参数可以设置为0，1，2，解释如下：0：log buffer中的数据将以每秒一次的
    频率写入到log file中，且同时会进行文件系统到磁盘的同步操作，但是每个事务的
    commit并不会触发任何log buffer 到log file的刷新或者文件系统到磁盘的刷新操作
    ；
    1：在每次事务提交的时候将log buffer 中的数据都会写入到log file，同时也会触
    发文件系统到磁盘的同步；
    2：事务提交会触发log buffer 到log file的刷新，但并不会触发磁盘文件系统到磁
    盘的同步。此外，每秒会有一次文件系统到磁盘同步操作。此外，MySQL文档中还提到
    ，这几种设置中的每秒同步一次的机制，可能并不会完全确保非常准确的每秒就一定
    会发生同步，还取决于进程调度的问题。实际上，InnoDB 能否真正满足此参数所设置
    值代表的意义正常 Recovery 还是受到了不同 OS 下文件系统以及磁盘本身的限制，
    可能有些时候在并没有真正完成磁盘同步的情况下也会告诉 mysqld 已经完成了磁盘
    同步。
  • innodb_max_dirty_pages_pct （global）这个参数和上面的各个参数不同，他不是用
    来设置用于缓存某种数据的内存大小的一个参数，而是用来控制在 InnoDB Buffer
    Pool 中可以不用写入数据文件中的Dirty Page 的比例（已经被修但还没有从内存中
    写入到数据文件的脏数据）。这个比例值越大，从内存到磁盘的写入操作就会相对减
    少，所以能够一定程度下减少写入操作的磁盘IO。但是，如果这个比例值过大，当数
    据库 Crash 之后重启的时间可能就会很长，因为会有大量的事务数据需要从日志文件
    恢复出来写入数据文件中。同时，过大的比例值同时可能也会造成在达到比例设定上
    限后的 flush 操作“过猛”而导致性能波动很大。

上面这几个参数是 MySQL 中为了减少磁盘物理IO而设计的主要参数，对 MySQL 的性能起
到了至关重要的作用。
—EOF—
按照 mcsrainbow 朋友的要求，这里列一下根据以往经验得到的相关参数的建议值：

  • query_cache_type : 如果全部使用innodb存储引擎，建议为0，如果使用MyISAM 存储
    引擎，建议为2，同时在SQL语句中显式控制是否是哟你gquery cache
  • query_cache_size: 根据命中率（Qcache_hits/(Qcache_hits+Qcache_inserts)*100)
    ）进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适
    当调大
  • binlog_cache_size: 一般环境2MB～4MB是一个合适的选择，事务较大且写入频繁的数
    据库环境可以适当调大，但不建议超过32MB
  • key_buffer_size: 如果不使用MyISAM存储引擎，16MB足以，用来缓存一些系统表信息
    等。如果使用 MyISAM存储引擎，在内存允许的情况下，尽可能将所有索引放入内存，
    简单来说就是“越大越好”
  • bulk_insert_buffer_size: 如果经常性的需要使用批量插入的特殊语句（上面有说明
    ）来插入数据，可以适当调大该参数至16MB～32MB，不建议继续增大，某人8MB
  • innodb_buffer_pool_size: 如果不使用InnoDB存储引擎，可以不用调整这个参数，如
    果需要使用，在内存允许的情况下，尽可能将所有的InnoDB数据文件存放如内存中，
    同样将但来说也是“越大越好”
  • innodb_additional_mem_pool_size: 一般的数据库建议调整到8MB～16MB，如果表特
    别多，可以调整到32MB，可以根据error log中的信息判断是否需要增大
  • innodb_log_buffer_size: 默认是1MB，系的如频繁的系统可适当增大至4MB～8MB。当
    然如上面介绍所说，这个参数实际上还和另外的flush参数相关。一般来说不建议超过
    32MB
  • innodb_max_dirty_pages_pct: 根据以往的经验，重启恢复的数据如果要超过1GB的话
    ，启动速度会比较慢，几乎难以接受，所以建议不大于 1GB/
    innodb_buffer_pool_size(GB)*100 这个值。当然，如果你能够忍受启动时间比较长
    ，而且希望尽量减少内存至磁盘的flush，可以将这个值调整到90，但不建议超过90

注：以上取值范围仅仅只是我的根据以往遇到的数据库场景所得到的一些优化经验值，并
不一定适用于所有场景，所以在实际优化过程中还需要大家自己不断的调整分析，也欢迎
大家随时通过 Mail 与我联系沟通交流优化或者是架构方面的技术，一起探讨相互学习。
 


Mysql优化总结


一、索引
1、创建索引：
（1）．ALTER TABLE   
 ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。    
    
 ALTER TABLE table_name ADD INDEX index_name (column_list)   
  
 ALTER TABLE table_name ADD UNIQUE (column_list)   
  
 ALTER TABLE table_name ADD PRIMARY KEY (column_list)   
  
（2）、CREATE INDEX   
 CREATE INDEX可对表增加普通索引或UNIQUE索引。   
  
 CREATE INDEX index_name ON table_name (column_list)   
  
 CREATE UNIQUE INDEX index_name ON table_name (column_list)  
2、查看索引  
  
 mysql> show index from tblname;   
  
 mysql> show keys from tblname; 
3、删除索引
 可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP
INDEX可以在ALTER TABLE 内部作为一条语句处理，语法如下。  
 DROP INDEX index_name ON talbe_name   
  
 ALTER TABLE table_name DROP INDEX index_name   
  
 ALTER TABLE table_name DROP PRIMARY KEY   

索引：http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html
**explain +select ·····用来获取select语句的执行的相关信息及索引的使用等
**describe table table_name;
**analyze table table_name;查看表的信息，帮助优化
**show 查看执行状态

二、my.ini中的配置
http://www.chinaz.com/program/2009/1210/100740.shtml
mysql > show status; 可以查看具体的设置服务器的状态
具体的配置呀什么，没有亲自试验过

三、数据表引擎
 1、MyISAM：mysql默认的
 2、InnoDB：支持事务、锁、外键、聚簇索引
引擎介绍：http://blog.csdn.net/cheungjustin/article/details/5999880
 http://limaolinjia.blog.163.com/blog/static/539162282011012145139/

四、索引的类型：
 1、B-Tree索引
 2、hash索引
具体的参考还是一）

五、事务
数据表引擎使用InnoDB
http://www.cnblogs.com/winner/archive/2011/11/09/2242272.html


六、存储过程
经编译和优化后存储在数据库服务器中，运行效率高，可以降低客户机和服务器之间的通
信量，有利于集中控制，易于维护（P247）
http://blog.sina.com.cn/s/blog_52d20fbf0100ofd5.html

七、mysql profiling（mysql性能分析器）优化sql语句
查看SQL执行消耗系统资源的信息
++++需要开启+++
具体使用：http://www.jiunile.com/
mysql-profiling%E7%9A%84%E4%BD%BF%E7%94%A8.html

八、慢查询日志
++++需要开启++++
通过慢日志查询可以知道哪些SQL语句执行效率低下，那些sql语句使用的频率高等
对MySQL查询语句的监控、分析、优化是MySQL优化非常重要的一步。开启慢查询日志后，
由于日志记录操作，在一定程度上会占用CPU资源影响mysql的性能，但是可以阶段性开启
来定位性能瓶颈。
具体参考：http://blog.csdn.net/renzhenhuai/article/details/8839874

关于mysql的一些讲解：http://www.ccvita.com/category/mysql


阅读更多登录后自动展开
想对作者说点什么？我来说一句
 

MySQL性能调优——索引详解与索引的优化

zhangliangzi zhangliangzi

05-11 2.2万

——索引优化，可以说是数据库相关优化、理解尤其是查询优化中最常用的优化手段之一。
所以，只有深入索引的实现原理、存储方式、不同索引间区别，才能设计或使用最优的索
引，最大幅度的提升查询效率！一、BT...

 

数据库SQL性能优化之详解

ComTu ComTu

11-06 335

一、问题的提出在应用系统开发初期，由于开发数据库数据比较少，对于查询SQL语句，复
杂视图的的编写等体会不出SQL语句各种写法的性能优劣，但是如果将应用系统提交实际应
用后，随着数据库中数据的增加，系...

 

数据库SQL优化大总结1之- 百万级数据库优化方案

wuhuagu_wuhuaguo wuhuagu_wuhuaguo

06-06 2.9万

转自：https://mp.weixin.qq.com/s?__biz=MzIxMjg4NDU1NA==&mid=2247483684&idx=1&sn
=f5abc60e696b2063e43cd9c...

 

数据库优化一般思路(个人经验之谈)

zhoupan301415 zhoupan301415

10-17 3950

随着系统规模的不断增加，数据量和并发量不断增大，整个系统架构中最先受到冲击而形
成瓶颈的，定然是数据库，因此数据库层面的优化，是一个程序员不可或缺的技能，以下
是我在使用数据库中的一些心得，有不足之处，还...

 

MySql数据库优化可以从哪几个方面进行？

q602075961 q602075961

05-01 1.8万

1、数据库优化可以从以下几个方面进行：2、项目中，优化mysql之前，首先要开启慢查询
日志，在分析慢查询日志.1,查看所有日志状态： show variables like '%quer%';2,查
看...

 

数据库优化方案

axin66ok axin66ok

08-21 4.2万

SQL语句优化方案 1. 高效地进行SQL语句设计：通常情况下，可以采用下面的方法优化SQL
对数据操作的表现：（1）减少对数据库的查询次数，即减少对系统资源的请求，使用快照
和显形图等分布...

 

mysql数据库优化大全

weixin_38112233 weixin_38112233

01-14 4078

数据库优化 sql语句优化索引优化加缓存读写分离分区分布式数据库（垂直切分）水平切
分 MyISAM和InnoDB的区别： 1. InnoDB支持事务，MyISAM不支持...

 

数据库查询优化策略

qq_25235807 qq_25235807

05-04 3078

数据库查询优化逻辑层查询优化策略1.尽可能的早做选择和投影（基本思路）：可以使中
间结果变小，节省几个数量级的执行时间 2.把选择和投影串接起来：一元运算序列可一起
执行，只需对整个关系进行一趟扫描 ...

 

数据库的优化以及如何提高数据库性能

allen_he_123 allen_he_123

02-27 968

硬件调整性能 1、最有可能影响性能的是磁盘和网络吞吐量，解决办法就是扩大虚拟内存
，以此来保证有足够扩充的空间； 2、把数据库服务器上的不必要的服务关闭； 3、把数
据库服务器和主域服务器分开...

 

数据库优化总结(比较全面)

pengpeng__ pengpeng__

04-24 169

1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上
建立索引。2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃
使用索引...

相关热词

or数据库 was数据库数据库or和in 数据库by 数据库和
[feedLoadin]

没有更多推荐了，返回首页

个人资料

[3_yzllz001]

xianmin_yan

关注

原创
    112

粉丝
    99

喜欢
    133

评论
    48

等级：
     

访问：
    44万+

积分：
    4292

排名：
    1万+

勋章：

持之以恒

授予每个自然月内发布4篇或4篇以上原创或翻译IT博文的用户。不积跬步无以至千里，不
积小流无以成江海，程序人生的精彩需要坚持不懈地积累！


 

    我的Github


欢迎Follow、Fork、Star

最新文章

  • JAVA实现文件下载打包（精简版）
  • 获得页面url的某个url参数的值
  • fzu 2216 The Longest Straight
  • 如何解决ajax跨域问题（转）
  • 微信卡卷总结

个人分类

  • topcoder 2篇
  • 01背包 1篇
  • 快速排序 2篇
  • kmp 10篇
  • 线段树 4篇
  • 最小生成树 2篇
  • 并查集 2篇
  • codeforces 6篇
  • 母函数 1篇
  • Trie 2篇
  • 动态规划 1篇
  • 全排列 1篇
  • 拓扑排序 2篇
  • 贪心 1篇
  • 剑指offer 16篇
  • Github 6篇
  • java web 3篇
  • spring 11篇
  • LintCode 1篇
  • 多线程 1篇
  • navicat 1篇
  • java 16篇
  • 设计模式 1篇
  • maven 4篇
  • IDEA 4篇
  • JVM 1篇
  • Mybatis 5篇
  • mysql 6篇
  • tomcat 2篇
  • spring boot 2篇
  • gradle 3篇
  • MD5 1篇
  • gitlib 1篇
  • socket 1篇
  • springmvc 3篇
  • alipay 1篇
  • git 4篇
  • 数据库 1篇
  • Spring事务 1篇
  • aop 1篇
  • 注解 1篇
  • 并发 2篇
  • DAO 1篇
  • jdbc 1篇
  • 进程 1篇
  • 线程 2篇
  • angular js 7篇
  • dubbo 2篇
  • youtube 1篇
  • jquery 2篇
  • 面试 1篇
  • javascript 1篇
  • 下载 1篇

展开

归档

  • 2018年4月 1篇
  • 2017年9月 1篇
  • 2017年8月 3篇
  • 2017年7月 7篇
  • 2017年6月 8篇
  • 2017年5月 10篇
  • 2017年4月 10篇
  • 2017年3月 8篇
  • 2017年2月 22篇
  • 2017年1月 27篇
  • 2016年12月 24篇
  • 2016年11月 11篇
  • 2016年10月 4篇
  • 2016年8月 16篇
  • 2016年7月 7篇
  • 2016年6月 5篇
  • 2016年4月 7篇
  • 2016年3月 2篇
  • 2016年1月 2篇
  • 2015年12月 2篇
  • 2015年11月 1篇
  • 2015年9月 3篇
  • 2015年8月 1篇
  • 2015年7月 5篇
  • 2015年4月 1篇

展开

热门文章

  • 数据库性能优化详解

    阅读量：122151

  • 使用Spring Boot开发Restful程序

    阅读量：26519

  • data-toggle与data-target的作用

    阅读量：25620

  • 快速排序原理剖析

    阅读量：17748

  • Proxy SwitchySharp使用

    阅读量：17152

最新评论

  • 快速排序原理剖析

    qq_40317897：if(left&gt;right)这句错了，应该是if(left&gt;=righ...

  • youtube上传视频

    xiongtao63：[reply]xy1994_Zhang[/reply] 你好你解决了吗这个问题，我也遇到了
    不知道...

  • AOP的底层实现

    qq_33199919：还能再深入一点吗，撸一下源码？

  • 数据库性能优化详解

    qq_34971162：谢谢大神

  • 数据库性能优化详解

    u012704246：很详细的数据库优化思路教程，学习了，感谢博主

登录
注册

  • 点赞取消点赞
   
    61
   
  • 评论

    13

  • 目录
  • 收藏
  •  手机看
  • 上一篇
  • 下一篇
  • 
    [2016080217]
  • 更多
      □ 上一篇
      □ 下一篇

